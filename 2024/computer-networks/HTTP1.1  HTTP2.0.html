<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>zxd's Blog</title>
    <meta name="description" content="so easy">
    <meta name="generator" content="VitePress v1.0.1">
    <link rel="preload stylesheet" href="/assets/style.B2JdIB9P.css" as="style">
    
    <script type="module" src="/assets/app.DsewOzab.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Bu8hRsVA.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/framework.C5O6QHj3.js">
    <link rel="modulepreload" href="/assets/chunks/theme.bV7EO5Vg.js">
    <link rel="modulepreload" href="/assets/2024_computer-networks_HTTP1.1  HTTP2.0.md.CLCMcnxa.lean.js">
    <link rel="icon" href="/icon.webp">
    <script src="/lib/medium-zoom.js"></script>
    <script src="/zoom-image.js"></script>
    <meta name="referrer" content="no-referrer">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-e177b3f2><!--[--><!--]--><!--[--><span tabindex="-1" data-v-bef3cbf0></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-bef3cbf0> Skip to content </a><!--]--><!----><header class="VPNav" data-v-e177b3f2 data-v-1226d7c8><div class="VPNavBar has-sidebar top" data-v-1226d7c8 data-v-5006301a><div class="wrapper" data-v-5006301a><div class="container" data-v-5006301a><div class="title" data-v-5006301a><div class="VPNavBarTitle has-sidebar" data-v-5006301a data-v-e1ddb017><a class="title" href="/" data-v-e1ddb017><!--[--><!--]--><!--[--><img class="VPImage logo" src="/user.png" alt data-v-10b417ca><!--]--><span data-v-e1ddb017>zxd&#39;s Blog</span><!--[--><!--]--></a></div></div><div class="content" data-v-5006301a><div class="content-body" data-v-5006301a><!--[--><!--]--><div class="VPNavBarSearch search" data-v-5006301a><!--[--><!----><div id="docsearch"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-5006301a data-v-0884e606><span id="main-nav-aria-label" class="visually-hidden" data-v-0884e606>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/2024/computer-networks/OSI%20TCP%20_%20UDP.html" tabindex="0" data-v-0884e606 data-v-98ad1aa1><!--[--><span data-v-98ad1aa1>网络</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/2024/typescript/1.%20TS-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html" tabindex="0" data-v-0884e606 data-v-98ad1aa1><!--[--><span data-v-98ad1aa1>typescript</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/2024/vue/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html" tabindex="0" data-v-0884e606 data-v-98ad1aa1><!--[--><span data-v-98ad1aa1>vue</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-0884e606 data-v-753158ba><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-753158ba><span class="text" data-v-753158ba><!----><span data-v-753158ba>课堂教学</span><span class="vpi-chevron-down text-icon" data-v-753158ba></span></span></button><div class="menu" data-v-753158ba><div class="VPMenu" data-v-753158ba data-v-e7e96bb5><div class="items" data-v-e7e96bb5><!--[--><!--[--><div class="VPMenuLink" data-v-e7e96bb5 data-v-a96ee391><a class="VPLink link" href="/course/01-WebAPI/day01/web-day01.html" data-v-a96ee391><!--[-->01 WebAPI<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7e96bb5 data-v-a96ee391><a class="VPLink link" href="/course/02-Echarts/day01/01-echarts.html" data-v-a96ee391><!--[-->02 Echarts<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7e96bb5 data-v-a96ee391><a class="VPLink link" href="/course/03-JSAdvance/day01/JS-day01.html" data-v-a96ee391><!--[-->03 JS Advance<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7e96bb5 data-v-a96ee391><a class="VPLink link" href="/course/04-Git/day01/day01.html" data-v-a96ee391><!--[-->04 Git<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7e96bb5 data-v-a96ee391><a class="VPLink link" href="/course/05-Node/day01/day01.html" data-v-a96ee391><!--[-->05 Node<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7e96bb5 data-v-a96ee391><a class="VPLink link" href="/course/06-Vue/day07/day07.html" data-v-a96ee391><!--[-->06 Vue<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/tips/%E7%BD%91%E7%AB%99%E8%B5%84%E6%BA%90.html" tabindex="0" data-v-0884e606 data-v-98ad1aa1><!--[--><span data-v-98ad1aa1>网站资源</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-5006301a data-v-9eb31107><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-9eb31107 data-v-94a65446 data-v-f5127aad><span class="check" data-v-f5127aad><span class="icon" data-v-f5127aad><!--[--><span class="vpi-sun sun" data-v-94a65446></span><span class="vpi-moon moon" data-v-94a65446></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-5006301a data-v-6bac7ebe data-v-8a5c2685><!--[--><a class="VPSocialLink no-icon" href="https://github.com/zxdfe" aria-label="github" target="_blank" rel="noopener" data-v-8a5c2685 data-v-22ad8c1d><span class="vpi-social-github" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-5006301a data-v-c5935333 data-v-753158ba><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-753158ba><span class="vpi-more-horizontal icon" data-v-753158ba></span></button><div class="menu" data-v-753158ba><div class="VPMenu" data-v-753158ba data-v-e7e96bb5><!----><!--[--><!--[--><!----><div class="group" data-v-c5935333><div class="item appearance" data-v-c5935333><p class="label" data-v-c5935333>Appearance</p><div class="appearance-action" data-v-c5935333><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-c5935333 data-v-94a65446 data-v-f5127aad><span class="check" data-v-f5127aad><span class="icon" data-v-f5127aad><!--[--><span class="vpi-sun sun" data-v-94a65446></span><span class="vpi-moon moon" data-v-94a65446></span><!--]--></span></span></button></div></div></div><div class="group" data-v-c5935333><div class="item social-links" data-v-c5935333><div class="VPSocialLinks social-links-list" data-v-c5935333 data-v-8a5c2685><!--[--><a class="VPSocialLink no-icon" href="https://github.com/zxdfe" aria-label="github" target="_blank" rel="noopener" data-v-8a5c2685 data-v-22ad8c1d><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-5006301a data-v-35979f45><span class="container" data-v-35979f45><span class="top" data-v-35979f45></span><span class="middle" data-v-35979f45></span><span class="bottom" data-v-35979f45></span></span></button></div></div></div></div><div class="divider" data-v-5006301a><div class="divider-line" data-v-5006301a></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-e177b3f2 data-v-106e26b8><div class="container" data-v-106e26b8><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-106e26b8><span class="vpi-align-left menu-icon" data-v-106e26b8></span><span class="menu-text" data-v-106e26b8>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-106e26b8 data-v-6fa19865><button data-v-6fa19865>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-e177b3f2 data-v-981c6a7e><div class="curtain" data-v-981c6a7e></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-981c6a7e><span class="visually-hidden" id="sidebar-aria-label" data-v-981c6a7e> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-981c6a7e><section class="VPSidebarItem level-0 has-active" data-v-981c6a7e data-v-d799ecce><div class="item" role="button" tabindex="0" data-v-d799ecce><div class="indicator" data-v-d799ecce></div><h2 class="text" data-v-d799ecce>computer-networks</h2><!----></div><div class="items" data-v-d799ecce><!--[--><div class="VPSidebarItem level-1 is-link" data-v-d799ecce data-v-d799ecce><div class="item" data-v-d799ecce><div class="indicator" data-v-d799ecce></div><a class="VPLink link link" href="/2024/computer-networks/CDN%E7%9B%B8%E5%85%B3.html" data-v-d799ecce><!--[--><p class="text" data-v-d799ecce>CDN相关</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d799ecce data-v-d799ecce><div class="item" data-v-d799ecce><div class="indicator" data-v-d799ecce></div><a class="VPLink link link" href="/2024/computer-networks/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.html" data-v-d799ecce><!--[--><p class="text" data-v-d799ecce>DNS域名解析</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d799ecce data-v-d799ecce><div class="item" data-v-d799ecce><div class="indicator" data-v-d799ecce></div><a class="VPLink link link" href="/2024/computer-networks/HTTP%20HTTPS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html" data-v-d799ecce><!--[--><p class="text" data-v-d799ecce>HTTP HTTPS工作原理</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d799ecce data-v-d799ecce><div class="item" data-v-d799ecce><div class="indicator" data-v-d799ecce></div><a class="VPLink link link" href="/2024/computer-networks/HTTP1.1%20%20HTTP2.0.html" data-v-d799ecce><!--[--><p class="text" data-v-d799ecce>HTTP1.1  HTTP2.0</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d799ecce data-v-d799ecce><div class="item" data-v-d799ecce><div class="indicator" data-v-d799ecce></div><a class="VPLink link link" href="/2024/computer-networks/OSI%20TCP%20_%20UDP.html" data-v-d799ecce><!--[--><p class="text" data-v-d799ecce>OSI TCP _ UDP</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d799ecce data-v-d799ecce><div class="item" data-v-d799ecce><div class="indicator" data-v-d799ecce></div><a class="VPLink link link" href="/2024/computer-networks/XSS%20CSRF.html" data-v-d799ecce><!--[--><p class="text" data-v-d799ecce>XSS CSRF</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d799ecce data-v-d799ecce><div class="item" data-v-d799ecce><div class="indicator" data-v-d799ecce></div><a class="VPLink link link" href="/2024/computer-networks/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98.html" data-v-d799ecce><!--[--><p class="text" data-v-d799ecce>浏览器缓存</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d799ecce data-v-d799ecce><div class="item" data-v-d799ecce><div class="indicator" data-v-d799ecce></div><a class="VPLink link link" href="/2024/computer-networks/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html" data-v-d799ecce><!--[--><p class="text" data-v-d799ecce>跨域解决方案</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-e177b3f2 data-v-73b957a9><div class="VPDoc has-sidebar has-aside" data-v-73b957a9 data-v-40255539><!--[--><!--]--><div class="container" data-v-40255539><div class="aside" data-v-40255539><div class="aside-curtain" data-v-40255539></div><div class="aside-container" data-v-40255539><div class="aside-content" data-v-40255539><div class="VPDocAside" data-v-40255539 data-v-6866a455><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" role="navigation" data-v-6866a455 data-v-9c79f3d1><div class="content" data-v-9c79f3d1><div class="outline-marker" data-v-9c79f3d1></div><div class="outline-title" role="heading" aria-level="2" data-v-9c79f3d1>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-9c79f3d1><span class="visually-hidden" id="doc-outline-aria-label" data-v-9c79f3d1> Table of Contents for current page </span><ul class="VPDocOutlineItem root" data-v-9c79f3d1 data-v-9937af2f><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-6866a455></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-40255539><div class="content-container" data-v-40255539><!--[--><!--]--><main class="main" data-v-40255539><div style="position:relative;" class="vp-doc _2024_computer-networks_HTTP1_1%20%20HTTP2_0" data-v-40255539><div><h2 id="http-0-9" tabindex="-1">HTTP/0.9 <a class="header-anchor" href="#http-0-9" aria-label="Permalink to &quot;HTTP/0.9&quot;">​</a></h2><p>HTTP/0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 HTML 超文本的内容，所以被称为<strong>超文本传输协议</strong> 超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在<a href="https://baike.baidu.com/item/TCP/33012" target="_blank" rel="noreferrer">TCP</a>之上</p><h3 id="http-0-9的完整请求流程" tabindex="-1">HTTP/0.9的完整请求流程 <a class="header-anchor" href="#http-0-9的完整请求流程" aria-label="Permalink to &quot;HTTP/0.9的完整请求流程&quot;">​</a></h3><ol><li>因为 HTTP 都是基于 TCP 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议三次握手的过程</li><li>建立好连接之后，会发送一个 GET <strong>请求行</strong>的信息，如GET /index.html用来获取 index.html。</li><li>服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端</li><li>HTML 文档传输完成后，断开连接。<img src="https://cdn.nlark.com/yuque/0/2024/png/302528/1711710241821-b51bfab5-6516-4e83-8f4f-bd4941191eec.png#averageHue=%23f1f0df&amp;clientId=ud5d10680-0cf0-4&amp;from=paste&amp;id=u0f558ccb&amp;originHeight=309&amp;originWidth=1142&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue31ffac8-68d9-4ce4-99b9-f7abf7681ee&amp;title=" alt=""></li></ol><h4 id="http-0-9特点" tabindex="-1">HTTP/0.9特点 <a class="header-anchor" href="#http-0-9特点" aria-label="Permalink to &quot;HTTP/0.9特点&quot;">​</a></h4><h5 id="_1-只有一个请求行" tabindex="-1">1. <strong>只有一个请求行</strong> <a class="header-anchor" href="#_1-只有一个请求行" aria-label="Permalink to &quot;1. **只有一个请求行**&quot;">​</a></h5><p>并没有 HTTP 请求头和请求体 GET /index.html</p><h5 id="_2-服务器没有返回头信息" tabindex="-1">2. 服务器没有返回头信息 <a class="header-anchor" href="#_2-服务器没有返回头信息" aria-label="Permalink to &quot;2. 服务器没有返回头信息&quot;">​</a></h5><h5 id="_3-返回文件内容以-ascii-字符流传输" tabindex="-1">3.返回文件内容以 ASCII 字符流传输 <a class="header-anchor" href="#_3-返回文件内容以-ascii-字符流传输" aria-label="Permalink to &quot;3.返回文件内容以 ASCII 字符流传输&quot;">​</a></h5><p>返回的文件内容是以 ASCII 字符流来传输的。（因为都是HTML格式的文件，ASCII字符流最合适）</p><h2 id="http-1-0" tabindex="-1">HTTP/1.0 <a class="header-anchor" href="#http-1-0" aria-label="Permalink to &quot;HTTP/1.0&quot;">​</a></h2><p>时间：1996年 在浏览器中展示的不单是 HTML 文件了，还包括了 JavaScript、CSS、图片、音频、视频等不同类型的文件。因此<strong>支持多种类型的文件下载是 HTTP/1.0 的一个核心诉求</strong> 为了让客户端和服务器能更深入地交流，<strong>HTTP/1.0 引入了请求头和响应头</strong>，它们都是以为 Key-Value 形式保存的，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息 <img src="https://cdn.nlark.com/yuque/0/2024/png/302528/1711710241821-db9c3f98-58be-4713-a39b-7ad8d5b72dfe.png#averageHue=%23f1f0e1&amp;clientId=ud5d10680-0cf0-4&amp;from=paste&amp;id=uf73f7f15&amp;originHeight=309&amp;originWidth=1142&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udc0face0-c393-42b7-8d27-cf001282db8&amp;title=" alt=""> 那 HTTP/1.0 是怎么通过请求头和响应头来支持多种不同类型的数据呢？ 要支持多类型的文件，需要解决几个问题</p><ol><li><strong>浏览器需要知道服务器返回的数据是什么类型</strong>，才能根据不同的类型做针对性处理</li><li>单个文件数据量越来越大，为了减轻传输性能，服务器会对数据进行压缩后再传输，<strong>浏览器需要知道服务器的压缩方法</strong>。</li><li>浏览器要告诉服务器它想要<strong>什么语言版本</strong>的页面</li><li>由于增加了不同类型的文件，每种文件编码形式可能不一样，<strong>浏览器需要知道文件的编码类型</strong>。</li></ol><p>HTTP/1.0的方案是通过请求头和响应头来进行协商 在发起请求时候会通过 HTTP 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 请求头</span></span>
<span class="line"><span>accept: text/html  // 期望服务器返回html类型文件</span></span>
<span class="line"><span>accept-encoding: gzip, deflate, br  // 期望服务器可采用gzip、deflate、br其中一种压缩方式</span></span>
<span class="line"><span>accept-Charset: ISO-8859-1,utf-8   // 期望返回的文件编码是UTF-8, 或者ISO-8859-1</span></span>
<span class="line"><span>accept-language: zh-CN,zh       // 期望页面优先使用中文</span></span></code></pre></div><p>服务器会根据请求头的信息来准备响应数据，但最终浏览器需要根据响应头的信息来处理数据,</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 响应头</span></span>
<span class="line"><span>content-encoding: br  // 压缩方式</span></span>
<span class="line"><span>content-type: text/html; charset=UTF-8  // 返回文件的类型和编码</span></span></code></pre></div><h4 id="http-1-0新特性" tabindex="-1">HTTP/ 1.0新特性 <a class="header-anchor" href="#http-1-0新特性" aria-label="Permalink to &quot;HTTP/ 1.0新特性&quot;">​</a></h4><h5 id="_1-传输的数据不再仅限于文本-增加了head、post等新方法。" tabindex="-1">1. 传输的数据不再仅限于文本, 增加了HEAD、POST等新方法。 <a class="header-anchor" href="#_1-传输的数据不再仅限于文本-增加了head、post等新方法。" aria-label="Permalink to &quot;1. 传输的数据不再仅限于文本, 增加了HEAD、POST等新方法。&quot;">​</a></h5><h5 id="_2-引入了响应状态码" tabindex="-1">2. 引入了响应状态码 <a class="header-anchor" href="#_2-引入了响应状态码" aria-label="Permalink to &quot;2. 引入了响应状态码&quot;">​</a></h5><p>状态码是通过响应行的方式来通知浏览器的</p><h5 id="_3-提供cache机制" tabindex="-1">3.提供Cache机制 <a class="header-anchor" href="#_3-提供cache机制" aria-label="Permalink to &quot;3.提供Cache机制&quot;">​</a></h5><p>为了减轻服务器压力，<strong>提供了Cache机制</strong>，用来缓存已下载过的数据</p><h5 id="_4-引入了http-header-头部-概念-让http请求和响应更加灵活" tabindex="-1">4.引入了HTTP Header(头部)概念，让HTTP请求和响应更加灵活 <a class="header-anchor" href="#_4-引入了http-header-头部-概念-让http请求和响应更加灵活" aria-label="Permalink to &quot;4.引入了HTTP Header(头部)概念，让HTTP请求和响应更加灵活&quot;">​</a></h5><p>服务器需要统计客户端的基础信息，所以 HTTP/1.0 的请求头中还<strong>加入了用户代理的字段</strong></p><h5 id="_5-引入了协议版本号的概念" tabindex="-1">5.引入了协议版本号的概念 <a class="header-anchor" href="#_5-引入了协议版本号的概念" aria-label="Permalink to &quot;5.引入了协议版本号的概念&quot;">​</a></h5><p><strong>TCP连接的新建成本很高，因为需要客户端和服务器三次握手</strong>，并且开始时发送速率较慢（slow start）</p><h2 id="http-1-1" tabindex="-1">HTTP/1.1 <a class="header-anchor" href="#http-1-1" aria-label="Permalink to &quot;HTTP/1.1&quot;">​</a></h2><p>时间：1997年1月 目前为止主流版本</p><h3 id="_1-引入持久连接" tabindex="-1">1. 引入持久连接 <a class="header-anchor" href="#_1-引入持久连接" aria-label="Permalink to &quot;1. 引入持久连接&quot;">​</a></h3><p>HTTP/1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接三个阶段（如下图） <img src="https://cdn.nlark.com/yuque/0/2024/png/302528/1711710241831-86f3f640-f3de-40f4-9c9c-6e2d3edb5fa0.png#averageHue=%23fdf2e7&amp;clientId=ud5d10680-0cf0-4&amp;from=paste&amp;id=u7f0f5284&amp;originHeight=1088&amp;originWidth=1142&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3afbb8ff-d2bd-4740-b8bd-3db256e321a&amp;title=" alt=""> 如果在下载每个文件的时候，都需要经历建立 TCP 连接、传输数据和断开连接这样的步骤，无疑会增加大量无谓的开销。 <strong>HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以发送多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。</strong> 重点注意，虽然一个TCP连接可以发送多个HTTP请求，但是： <strong>HTTP / 1.1， 单个TCP连接，在同一时刻只能处理一个HTTP请求，意思是说：两个HTTP请求的生命周期不能重叠，也就是不能并行。</strong><img src="https://cdn.nlark.com/yuque/0/2024/png/302528/1711710242278-408b4489-5032-4c4e-a492-eab62d9fef0c.png#averageHue=%23f19b40&amp;clientId=ud5d10680-0cf0-4&amp;from=paste&amp;id=u3d2abab3&amp;originHeight=804&amp;originWidth=1140&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=99473&amp;status=done&amp;style=none&amp;taskId=u26cca176-05e2-4604-84bc-e39ca395229&amp;title=" alt="image.png"> 从上图可以看出，HTTP 的持久连接可以<strong>有效减少 TCP 建立连接和断开连接的次数</strong>，这样的好处是<strong>减少了服务器额外的负担，并提升整体 HTTP 的请求时长</strong> 持久连接在 HTTP/1.1 中是默认开启的，Connection： keep-alive. 如果不想要采用持久连接，可以在 HTTP 请求头中加上Connection: close。<strong>目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。</strong> （<strong>http/1.1中的一个tcp链接同时只能发起一个http请求！</strong> 浏览器会让每个域名同时最多建立6个tcp链接，也就是说同一个域名同时能支持6个http请求！）</p><h3 id="_2-不成熟的http管线化" tabindex="-1">2. 不成熟的HTTP管线化 <a class="header-anchor" href="#_2-不成熟的http管线化" aria-label="Permalink to &quot;2. 不成熟的HTTP管线化&quot;">​</a></h3><p>持久连接虽然能减少 TCP 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的队头阻塞的问题 <strong>HTTP/1.1 中试图通过管线化的技术来解决队头阻塞的问题</strong>。HTTP/1.1 中的管线化是指<strong>将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求</strong>。 HTTP / 2.0中废弃了管道。</p><h4 id="队头阻塞" tabindex="-1">队头阻塞 <a class="header-anchor" href="#队头阻塞" aria-label="Permalink to &quot;队头阻塞&quot;">​</a></h4><p>当顺序请求多个文件时，其中一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，这就是队头阻塞。 人们尝试过以下办法来解决队头阻塞问题</p><ol><li><strong>使用多个域名。</strong><ul><li>将同一页面的资源分散到不同域名，提升并发连接上线，因为浏览器对同一域名的HTTP连接并发最大为6个。</li></ul></li><li><strong>引入雪碧图</strong><ul><li>将多张小图合并成一张大图，将多个请求合并成一个请求。</li><li>带来的问题，某张小图更新了，需要重新请求大图，浪费大量网络带宽</li></ul></li><li><strong>将小图内联</strong><ul><li>将图片的二进制数据通过 base64 编码后，把编码数据嵌入到 HTML 或 CSS 文件中，以此来减少网络请求次数；</li></ul></li><li>使用webpack等打包工具 <ul><li>打包压缩多个JS文件到一个文件中，以一个请求代替多个请求。</li><li>带来的问题：当某个JS文件变化了，需要重新请求同一个包里的所有JS文件</li></ul></li><li><strong>按需加载</strong><ul><li>来减少第一时间的 HTTP 请求次数</li></ul></li></ol><h3 id="_3-提供虚拟主机支持-host" tabindex="-1">3. 提供虚拟主机支持(Host) <a class="header-anchor" href="#_3-提供虚拟主机支持-host" aria-label="Permalink to &quot;3. 提供虚拟主机支持(Host)&quot;">​</a></h3><p>在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。 因此，<strong>HTTP/1.1 的请求头中增加了 Host 字段</strong>，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理</p><h3 id="_4-支持动态生成内容-chunk-transfer-机制" tabindex="-1">4. 支持动态生成内容(Chunk transfer 机制) <a class="header-anchor" href="#_4-支持动态生成内容-chunk-transfer-机制" aria-label="Permalink to &quot;4. 支持动态生成内容(Chunk transfer 机制)&quot;">​</a></h3><p>在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据。不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。 HTTP/1.1 通过引入 <strong>Chunk transfer 机制</strong>来解决这个问题，<strong>服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持</strong>。</p><h3 id="_5-引入客户端cookie、安全机制" tabindex="-1">5. 引入客户端Cookie、安全机制 <a class="header-anchor" href="#_5-引入客户端cookie、安全机制" aria-label="Permalink to &quot;5. 引入客户端Cookie、安全机制&quot;">​</a></h3><ul><li>查看Cookie单独专题知识点</li></ul><h4 id="其它" tabindex="-1">其它 <a class="header-anchor" href="#其它" aria-label="Permalink to &quot;其它&quot;">​</a></h4><p>HTTP/ 1.1 <strong>在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content）</strong>，这样就方便了开发者自由的选择以便于充分利用带宽和连接</p><h3 id="http1-1的主要问题" tabindex="-1">HTTP1.1的主要问题 <a class="header-anchor" href="#http1-1的主要问题" aria-label="Permalink to &quot;HTTP1.1的主要问题&quot;">​</a></h3><h4 id="_1-http-1-1对带宽的利用率不理想" tabindex="-1">1. HTTP/1.1对带宽的利用率不理想 <a class="header-anchor" href="#_1-http-1-1对带宽的利用率不理想" aria-label="Permalink to &quot;1. HTTP/1.1对带宽的利用率不理想&quot;">​</a></h4><p>HTTP/1.1对带宽的利用率却并不理想，这也是 HTTP/1.1 的一个核心问题 <strong>带宽是指每秒最大能发送或者接收的字节数</strong>。我们把每秒能发送的最大字节数称为<strong>上行带宽</strong>，每秒能够接收的最大字节数称为<strong>下行带宽</strong> 之所以说 HTTP/1.1 对带宽的利用率不理想，是因为 HTTP/1.1 很难将带宽用满。比如我们常说的 100M 带宽，实际的下载速度能达到 12.5M/S，而采用 HTTP/1.1 时，也许在加载页面资源时最大只能使用到 2.5M/S，很难将 12.5M 全部用满。 主要由三个原因导致</p><h5 id="_1-tcp的慢启动" tabindex="-1">1. TCP的慢启动 <a class="header-anchor" href="#_1-tcp的慢启动" aria-label="Permalink to &quot;1. TCP的慢启动&quot;">​</a></h5><p>一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。 慢启动是 TCP 为了减少网络拥塞的一种策略，我们是没有办法改变的。</p><h5 id="_2-同时开启了多条-tcp-连接-那么这些连接会竞争固定的带宽" tabindex="-1">2. 同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽 <a class="header-anchor" href="#_2-同时开启了多条-tcp-连接-那么这些连接会竞争固定的带宽" aria-label="Permalink to &quot;2. 同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽&quot;">​</a></h5><p>因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。 <strong>资源竞争时无法区分优先级</strong>。</p><h5 id="_3-http-1-1-队头阻塞问题" tabindex="-1">3. HTTP/1.1 队头阻塞问题 <a class="header-anchor" href="#_3-http-1-1-队头阻塞问题" aria-label="Permalink to &quot;3. HTTP/1.1 队头阻塞问题&quot;">​</a></h5><p>在 HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。 对于 队头阻塞问题，只要传输层是TCP，就不会得到根本上的解决， http/2 利用流的的机制很大程度的缓解了这个问题，http/3 传输层换成了 UDP 才彻底解决这个问题</p><h5 id="总结-慢启动和-tcp-连接之间相互竞争带宽是由于-tcp-本身的机制导致的-而队头阻塞是由于-http-1-1-的机制导致的。" tabindex="-1">总结：慢启动和 TCP 连接之间相互竞争带宽是由于 TCP 本身的机制导致的，而队头阻塞是由于 HTTP/1.1 的机制导致的。 <a class="header-anchor" href="#总结-慢启动和-tcp-连接之间相互竞争带宽是由于-tcp-本身的机制导致的-而队头阻塞是由于-http-1-1-的机制导致的。" aria-label="Permalink to &quot;总结：慢启动和 TCP 连接之间相互竞争带宽是由于 TCP 本身的机制导致的，而队头阻塞是由于 HTTP/1.1 的机制导致的。&quot;">​</a></h5><h2 id="http-2-0" tabindex="-1">HTTP/2.0 <a class="header-anchor" href="#http-2-0" aria-label="Permalink to &quot;HTTP/2.0&quot;">​</a></h2><p>时间： 2015年 HTTP/ 2.0 比 HTTP / 1.1快了多少，感受一下 <a href="https://http2.akamai.com/demo" target="_blank" rel="noreferrer">https://http2.akamai.com/demo</a><img src="https://cdn.nlark.com/yuque/0/2024/png/302528/1711710241845-27480bbe-edd8-4717-be15-e26d8a2d3d1e.png#averageHue=%237e7e78&amp;clientId=ud5d10680-0cf0-4&amp;from=paste&amp;id=uf5f2e9c5&amp;originHeight=1076&amp;originWidth=1810&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u78e0e353-32f5-41c2-b176-d46ec454f36&amp;title=" alt=""> 针对HTTP/1.1的问题，HTTP/2 的解决方案可以总结为：<strong>一个域名只使用一个 TCP 长连接和消除队头阻塞问题</strong>。 <img src="https://cdn.nlark.com/yuque/0/2024/png/302528/1711710245061-6fbe81d0-f71d-4b48-b171-954b7f5588b8.png#averageHue=%23f4c483&amp;clientId=ud5d10680-0cf0-4&amp;from=paste&amp;id=u4f9a4855&amp;originHeight=1786&amp;originWidth=4526&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=2664480&amp;status=done&amp;style=none&amp;taskId=u83119db4-5177-4e92-8c94-b1fc8a5a4f0&amp;title=" alt="image.png"><strong>多路复用机制</strong>（<strong>Multiplexing</strong>） HTTP/2 使用了<strong>多路复用技术</strong>，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。 每个请求都有一个对应的ID， 如stream1, stream2 <img src="https://cdn.nlark.com/yuque/0/2024/jpeg/302528/1711710242900-ffc01bea-c811-42f9-bd10-ddbfe3715308.jpeg#averageHue=%23f8f8f7&amp;clientId=ud5d10680-0cf0-4&amp;from=paste&amp;id=u6eebaa36&amp;originHeight=859&amp;originWidth=866&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2f5e8973-aa17-4874-98f7-248039092f8&amp;title=" alt=""></p><h3 id="多路复用的实现原理" tabindex="-1">多路复用的实现原理 <a class="header-anchor" href="#多路复用的实现原理" aria-label="Permalink to &quot;多路复用的实现原理&quot;">​</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/302528/1711710243049-82f5149a-1ac0-41a6-8e04-ece8f62a362a.png#averageHue=%23242420&amp;clientId=ud5d10680-0cf0-4&amp;from=paste&amp;id=u593cf900&amp;originHeight=1156&amp;originWidth=1142&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=122638&amp;status=done&amp;style=none&amp;taskId=udab169fe-ed1a-4c8a-bf7e-7d8be8e274f&amp;title=" alt="image.png"> HTTP/2 添加了一个<strong>二进制分帧层</strong></p><ol><li>首先，浏览器准备请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。</li><li>这些数据经过<strong>二进制分帧层</strong>处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。</li><li>服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。</li><li>然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。</li><li>同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。</li><li>浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。</li></ol><p>从上面的流程可以看出，<strong>通过引入二进制分帧层，就实现了 HTTP 的多路复用技术</strong>。 <strong>HTTP / 2.0 与 HTTP / 1.1 发生改变的只是传输方式</strong>，通信语言并没有改变，所以不需要为HTTP / 2.0 重建生态。 ps. <strong>http/2是没必要用雪碧图了</strong></p><h3 id="http-2-0的特性" tabindex="-1">HTTP/2.0的特性 <a class="header-anchor" href="#http-2-0的特性" aria-label="Permalink to &quot;HTTP/2.0的特性&quot;">​</a></h3><h4 id="_1-引入二进制分帧层-实现http的多路复用" tabindex="-1">1. 引入二进制分帧层，实现HTTP的多路复用 <a class="header-anchor" href="#_1-引入二进制分帧层-实现http的多路复用" aria-label="Permalink to &quot;1. 引入二进制分帧层，实现HTTP的多路复用&quot;">​</a></h4><h4 id="_2-可以设置请求优先级" tabindex="-1">2. 可以设置请求优先级 <a class="header-anchor" href="#_2-可以设置请求优先级" aria-label="Permalink to &quot;2. 可以设置请求优先级&quot;">​</a></h4><h4 id="_3-头部压缩" tabindex="-1">3. 头部压缩 <a class="header-anchor" href="#_3-头部压缩" aria-label="Permalink to &quot;3. 头部压缩&quot;">​</a></h4><p>无论是 HTTP/1.1 还是 HTTP/2，它们都有请求头和响应头，这是浏览器和服务器的通信语言。HTTP/2 对请求头和响应头进行了压缩。</p><h4 id="_4-服务器推送" tabindex="-1">4. 服务器推送 <a class="header-anchor" href="#_4-服务器推送" aria-label="Permalink to &quot;4. 服务器推送&quot;">​</a></h4><p>除了设置请求的优先级外，<strong>HTTP/2 还可以直接将数据提前推送到浏览器。</strong> 可以想象这样一个场景，当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。</p><h4 id="_5-增强了安全性-事实上要求加密通信" tabindex="-1">5. 增强了安全性，事实上要求加密通信 <a class="header-anchor" href="#_5-增强了安全性-事实上要求加密通信" aria-label="Permalink to &quot;5. 增强了安全性，事实上要求加密通信&quot;">​</a></h4><h3 id="http-2-0缺陷" tabindex="-1">HTTP / 2.0缺陷 <a class="header-anchor" href="#http-2-0缺陷" aria-label="Permalink to &quot;HTTP / 2.0缺陷&quot;">​</a></h3><h4 id="tcp的队头阻塞" tabindex="-1">TCP的队头阻塞 <a class="header-anchor" href="#tcp的队头阻塞" aria-label="Permalink to &quot;TCP的队头阻塞&quot;">​</a></h4><p>我们把<strong>在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞。</strong> 虽然 HTTP/2 解决了应用层面的队头阻塞问题，不过和 HTTP/1.1 一样，HTTP/2 依然是基于 TCP 协议的，而 TCP 最初就是为了单连接而设计的。可以把 TCP 连接看成是两台计算机之前的一个虚拟管道，计算机的一端将要传输的数据按照顺序放入管道，最终数据会以相同的顺序出现在管道的另外一头。 HTTP /1.1 协议栈中 TCP传输数据如图 <img src="https://cdn.nlark.com/yuque/0/2024/png/302528/1711710243083-a2268446-9f75-4a90-b4fe-6b86689b00bd.png#averageHue=%23fcefdd&amp;clientId=ud5d10680-0cf0-4&amp;from=paste&amp;id=u7e25b898&amp;originHeight=232&amp;originWidth=1142&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u031cd8f8-2286-4606-b055-b6256dc91d7&amp;title=" alt=""> 如果在数据传输的过程中，有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。 <img src="https://cdn.nlark.com/yuque/0/2024/png/302528/1711710243298-4c84ebd0-1aaa-4ba7-93b6-bb19ac18b06a.png#averageHue=%23fbe6c7&amp;clientId=ud5d10680-0cf0-4&amp;from=paste&amp;id=u593d5273&amp;originHeight=288&amp;originWidth=1142&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=89724&amp;status=done&amp;style=none&amp;taskId=ud5903d7e-c548-4ca4-9bd7-eae2fad1ac8&amp;title=" alt="image.png"> HTTP /2.0 的传输过程 <img src="https://cdn.nlark.com/yuque/0/2024/png/302528/1711710243514-fae87b8c-b32a-4d74-b7fc-7a33357db95a.png#averageHue=%23fcf3e1&amp;clientId=ud5d10680-0cf0-4&amp;from=paste&amp;id=u00501990&amp;originHeight=231&amp;originWidth=1142&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=66098&amp;status=done&amp;style=none&amp;taskId=u64a48984-dc85-4535-8cd5-4a7919da23b&amp;title=" alt="image.png"> 在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。 <strong>当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好</strong>。</p><h4 id="tcp建立连接的延时" tabindex="-1">TCP建立连接的延时 <a class="header-anchor" href="#tcp建立连接的延时" aria-label="Permalink to &quot;TCP建立连接的延时&quot;">​</a></h4><p>除了 TCP 队头阻塞之外，TCP 的握手过程也是影响传输效率的一个重要因素 <strong>网络延迟又称为 RTT（Round Trip Time）</strong> 我们把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT（如下图）。RTT 是反映网络性能的一个重要指标。 <img src="https://cdn.nlark.com/yuque/0/2024/png/302528/1711710243652-c0abcade-915e-489c-8ddf-422d6f25ebf3.png#averageHue=%23fbfafa&amp;clientId=ud5d10680-0cf0-4&amp;from=paste&amp;id=ue97696d0&amp;originHeight=615&amp;originWidth=1142&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u11ff171b-7977-47c6-9125-16e69d1edfa&amp;title=" alt=""> 我们知道 HTTP/1 和 HTTP/2 都是使用 TCP 协议来传输的，而如果使用 HTTPS 的话，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，这样就需要有两个握手延迟过程。</p><ol><li>在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输</li><li>进行 TLS 连接，TLS 有两个版本——TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致是需要 1～2 个 RTT</li></ol><h4 id="tcp-协议僵化" tabindex="-1">TCP 协议僵化 <a class="header-anchor" href="#tcp-协议僵化" aria-label="Permalink to &quot;TCP 协议僵化&quot;">​</a></h4><p>TCP 协议存在队头阻塞和建立连接延迟等缺点，那我们是不是可以通过改进 TCP 协议来解决这些问题呢，非常困难 因为</p><ul><li><strong>中间设备僵化</strong></li><li>操作系统更新滞后</li></ul><h2 id="http-3-0" tabindex="-1">HTTP/3.0 <a class="header-anchor" href="#http-3-0" aria-label="Permalink to &quot;HTTP/3.0&quot;">​</a></h2><p>在 HTTP/1.1 时代，为了提升并行下载效率，浏览器为每个域名维护了 6 个 TCP 连接；而采用 HTTP/2 之后，浏览器只需要为每个域名维护 1 个 TCP 持久连接，同时还解决了 HTTP/1.1 队头阻塞的问题。(TCP层仍然存在数据包级别的队头阻塞问题)</p><h3 id="quic协议" tabindex="-1">QUIC协议 <a class="header-anchor" href="#quic协议" aria-label="Permalink to &quot;QUIC协议&quot;">​</a></h3><p>HTTP/3 选择了一个折衷的方法——UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为 <strong>QUIC 协议</strong><img src="https://cdn.nlark.com/yuque/0/2024/png/302528/1711710244185-ceb8c82f-2f5c-453c-bcb3-3e7c02d79cc3.png#averageHue=%23fffefc&amp;clientId=ud5d10680-0cf0-4&amp;from=paste&amp;id=u9ecbd8b9&amp;originHeight=729&amp;originWidth=1142&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=92130&amp;status=done&amp;style=none&amp;taskId=uaaf631c4-b2b0-4d8f-a9ad-49558e9bbbf&amp;title=" alt="image.png"> HTTP/3 中的 QUIC 协议集合了以下几点功能</p><ol><li><strong>实现了类似 TCP 的流量控制、传输可靠性的功能</strong><ul><li>虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</li></ul></li><li><strong>集成了 TLS 加密功能</strong><ul><li>目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数</li></ul></li><li><strong>实现了 HTTP/2 中的多路复用功能</strong><ul><li>和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。<img src="https://cdn.nlark.com/yuque/0/2024/png/302528/1711710244177-9ec946da-bab1-4398-b246-e4698a81b48f.png#averageHue=%23fbf3e4&amp;clientId=ud5d10680-0cf0-4&amp;from=paste&amp;id=ub9bbc98b&amp;originHeight=266&amp;originWidth=1142&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=88566&amp;status=done&amp;style=none&amp;taskId=u053a1df9-008b-4e4a-aeda-bdc5d09c77f&amp;title=" alt="image.png"></li></ul></li><li><strong>实现了快速握手功能</strong><ul><li>由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度</li></ul></li></ol><h3 id="http-3-挑战" tabindex="-1">HTTP / 3 挑战 <a class="header-anchor" href="#http-3-挑战" aria-label="Permalink to &quot;HTTP / 3 挑战&quot;">​</a></h3><ol><li>从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Google版本的QUIIC和官方版本QUIC还存在非常大的差异</li><li>部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。</li><li>中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。</li></ol><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>影响 HTTP/1.1 效率的三个主要因素：</p><ol><li><strong>TCP 的慢启动、</strong></li><li><strong>多条 TCP 连接竞争带宽</strong></li><li><strong>队头阻塞</strong>。</li></ol><p>接下来我们分析了 HTTP/2 是如何采用多路复用机制来解决这些问题的。 <strong>多路复用是通过在协议栈中添加二进制分帧层来实现的，有了二进制分帧层还能够实现请求的优先级、服务器推送、头部压缩等特性，从而大大提升了文件传输效率</strong>。</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ol><li>浏览器工作原理 from GeekTime</li><li>透视HTTP协议 from GeekTime</li><li><a href="https://zhuanlan.zhihu.com/p/61423830" target="_blank" rel="noreferrer">你猜一个 TCP 连接上面能发多少个 HTTP 请求</a></li><li><a href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?" target="_blank" rel="noreferrer">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></li><li><a href="https://zhuanlan.zhihu.com/p/377173829" target="_blank" rel="noreferrer">HTTP/2对比HTTP/1.1，特性是什么？是如何解决队头阻塞与压缩头部的？</a></li><li><a href="https://juejin.cn/post/6985444039340326948#heading-9" target="_blank" rel="noreferrer">https://juejin.cn/post/6985444039340326948#heading-9</a></li><li><a href="https://mp.weixin.qq.com/s/nC-ynGuG_iEn1CVk2vM7xA" target="_blank" rel="noreferrer">HTTP/1.1报文详解</a></li></ol></div></div></main><footer class="VPDocFooter" data-v-40255539 data-v-0d70ac0d><!--[--><!--]--><!----><nav class="prev-next" data-v-0d70ac0d><div class="pager" data-v-0d70ac0d><a class="VPLink link pager-link prev" href="/2024/computer-networks/HTTP%20HTTPS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html" data-v-0d70ac0d><!--[--><span class="desc" data-v-0d70ac0d>Previous page</span><span class="title" data-v-0d70ac0d>HTTP HTTPS工作原理</span><!--]--></a></div><div class="pager" data-v-0d70ac0d><a class="VPLink link pager-link next" href="/2024/computer-networks/OSI%20TCP%20_%20UDP.html" data-v-0d70ac0d><!--[--><span class="desc" data-v-0d70ac0d>Next page</span><span class="title" data-v-0d70ac0d>OSI TCP _ UDP</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"2024_computer-networks_http https工作原理.md\":\"CwfpwMHm\",\"2024_computer-networks_cdn相关.md\":\"Bps6r3Jy\",\"2024_computer-networks_dns域名解析.md\":\"DSOw5XsI\",\"course_03-jsadvance_day01_js-day01.md\":\"CqukSAQ0\",\"course_04-git_day01_day01.md\":\"0KwehFnt\",\"course_05-node_day01_day01.md\":\"7mfDzuWz\",\"2024_computer-networks_xss csrf.md\":\"-REOycL8\",\"2024_computer-networks_浏览器缓存.md\":\"CmzGDco2\",\"2024_computer-networks_跨域解决方案.md\":\"DjITpmDg\",\"2024_typescript_1. ts-数据类型.md\":\"DSCK37Xb\",\"2024_vue_object.defineproperty.md\":\"DZOU1MHb\",\"2024_vue_响应式原理.md\":\"DCZphsQv\",\"2024_computer-networks_http1.1  http2.0.md\":\"CLCMcnxa\",\"course_04-git_day02_day02.md\":\"DIrbVP4K\",\"course_03-jsadvance_day04_js-day04.md\":\"CkN-hny-\",\"course_03-jsadvance_day03_js-day03.md\":\"DDTnTX92\",\"course_01-webapi_day07_web-day07.md\":\"Bo5tMlWo\",\"2024_vue_vue源码分析.md\":\"DxBXfFLm\",\"2024_typescript_2. ts-接口.md\":\"BHyzPp3u\",\"course_05-node_day03_day03.md\":\"DqzprzVf\",\"course_05-node_day04_day04.md\":\"CzOS7GVn\",\"course_06-vue_vuex-总结.md\":\"Ce4zaRQ8\",\"course_06-vue_day07_day07.md\":\"CrL4QlDm\",\"course_06-vue_day08_vue-2-8.md\":\"B3ns7wop\",\"2024_computer-networks_osi tcp _ udp.md\":\"CqI_os1m\",\"course_06-vue_安装vue2.7相关的插件，vue2和vite搭配使用必须安装.md\":\"DsMZfDiV\",\"course_07-typescript_day01_01 初识ts.md\":\"sResqsUJ\",\"course_10-api-8.1_day01_day01.md\":\"D_CVgd02\",\"course_10-api-8.1_day02_day02.md\":\"BpC3dcUz\",\"index.md\":\"aGlC6u_L\",\"tips_网站资源.md\":\"J9cjiBuW\",\"2024_typescript_4. ts-函数.md\":\"Ku3h1HIM\",\"course_03-jsadvance_day02_js-day02.md\":\"OtTJyEat\",\"course_06-vue_day11_day11-vuex入门.md\":\"C7NmIz2i\",\"course_06-vue_day10_day10-面经h5端-vant下.md\":\"8qhyWYy-\",\"course_06-vue_day13_day13-面经pc端-element下.md\":\"Bgjp_Edc\",\"course_06-vue_day09_day09-面经h5端-vant上.md\":\"Cvch1eSl\",\"course_01-webapi_day02_web-day02.md\":\"BVGIAXPs\",\"course_01-webapi_day05_web-day05.md\":\"WimGxrjA\",\"course_06-vue_day12_day12-面经pc端-element上.md\":\"Btx21YYR\",\"course_01-webapi_day03_web-day03.md\":\"MWUC50N1\",\"course_01-webapi_day04_web-day04.md\":\"CIWaXi5d\",\"course_01-webapi_day06_web-day06.md\":\"BNxCzIdi\",\"2024_typescript_3. ts-类.md\":\"CnwLysJ4\",\"course_05-node_day02_day02.md\":\"uYmU3ngW\",\"course_02-echarts_day02_02-echarts.md\":\"EuvpQfvC\",\"course_02-echarts_day01_01-echarts.md\":\"CuuMwbfT\",\"course_01-webapi_day01_web-day01.md\":\"BO8AfIKp\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"zxd's Blog\",\"description\":\"so easy\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"logo\":\"/user.png\",\"algolia\":{\"appId\":\"L0EMG34NNQ\",\"apiKey\":\"2f3bb9a9444f670387e88a77d8426f53\",\"indexName\":\"vitepress-course\"},\"outline\":[2,3],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/zxdfe\"}],\"nav\":[{\"text\":\"网络\",\"link\":\"/2024/computer-networks/OSI TCP _ UDP.md\",\"activeMatch\":\"/computer-networks/\"},{\"text\":\"typescript\",\"link\":\"/2024/typescript/1. TS-数据类型.md\"},{\"text\":\"vue\",\"link\":\"/2024/vue/Vue源码分析.md\"},{\"text\":\"课堂教学\",\"items\":[{\"text\":\"01 WebAPI\",\"link\":\"/course/01-WebAPI/day01/web-day01\"},{\"text\":\"02 Echarts\",\"link\":\"/course/02-Echarts/day01/01-echarts\"},{\"text\":\"03 JS Advance\",\"link\":\"/course/03-JSAdvance/day01/JS-day01\"},{\"text\":\"04 Git\",\"link\":\"/course/04-Git/day01/day01\"},{\"text\":\"05 Node\",\"link\":\"/course/05-Node/day01/day01\"},{\"text\":\"06 Vue\",\"link\":\"/course/06-Vue/day07/day07\"}]},{\"text\":\"网站资源\",\"link\":\"/tips/网站资源\"}],\"sidebar\":{\"/2024/computer-networks/\":[{\"text\":\"computer-networks\",\"items\":[{\"text\":\"CDN相关\",\"link\":\"/2024/computer-networks/CDN相关\"},{\"text\":\"DNS域名解析\",\"link\":\"/2024/computer-networks/DNS域名解析\"},{\"text\":\"HTTP HTTPS工作原理\",\"link\":\"/2024/computer-networks/HTTP HTTPS工作原理\"},{\"text\":\"HTTP1.1  HTTP2.0\",\"link\":\"/2024/computer-networks/HTTP1.1  HTTP2.0\"},{\"text\":\"OSI TCP _ UDP\",\"link\":\"/2024/computer-networks/OSI TCP _ UDP\"},{\"text\":\"XSS CSRF\",\"link\":\"/2024/computer-networks/XSS CSRF\"},{\"text\":\"浏览器缓存\",\"link\":\"/2024/computer-networks/浏览器缓存\"},{\"text\":\"跨域解决方案\",\"link\":\"/2024/computer-networks/跨域解决方案\"}]}],\"/course/\":[{\"text\":\"WebAPI\",\"collapsed\":false,\"items\":[{\"text\":\"day-01 DOM/获取元素\",\"link\":\"/course/01-WebAPI/day01/web-day01.md\"},{\"text\":\"day-02 事件/tab切换\",\"link\":\"/course/01-WebAPI/day02/web-day02.md\"},{\"text\":\"day-03 事件流/事件委托\",\"link\":\"/course/01-WebAPI/day03/web-day03.md\"},{\"text\":\"day-04 日期对/节点\",\"link\":\"/course/01-WebAPI/day04/web-day04.md\"},{\"text\":\"day-05 BOM/localStorage\",\"link\":\"/course/01-WebAPI/day05/web-day05.md\"},{\"text\":\"day-06 正则/案例\",\"link\":\"/course/01-WebAPI/day06/web-day06.md\"},{\"text\":\"day-07 放大镜\",\"link\":\"/course/01-WebAPI/day07/web-day07.md\"}]},{\"text\":\"Echarts\",\"collapsed\":false,\"items\":[{\"text\":\"day-01\",\"link\":\"/course/02-Echarts/day01/01-echarts.md\"},{\"text\":\"day-02\",\"link\":\"/course/02-Echarts/day02/02-echarts.md\"}]},{\"text\":\"JS Advance\",\"collapsed\":false,\"items\":[{\"text\":\"day-01 作用域/垃圾回收/闭包\",\"link\":\"/course/03-JSAdvance/day01/JS-day01.md\"},{\"text\":\"day-02 解构赋值/构造函数\",\"link\":\"/course/03-JSAdvance/day02/JS-day02.md\"},{\"text\":\"day-03 原型/原型链\",\"link\":\"/course/03-JSAdvance/day03/JS-day03.md\"},{\"text\":\"day-04 深浅拷贝/防抖节流\",\"link\":\"/course/03-JSAdvance/day04/JS-day04.md\"}]},{\"text\":\"Git\",\"collapsed\":false,\"items\":[{\"text\":\"day-01 本地操作\",\"link\":\"/course/04-Git/day01/day01.md\"},{\"text\":\"day-02 远端仓库\",\"link\":\"/course/04-Git/day02/day02.md\"}]},{\"text\":\"Node\",\"collapsed\":false,\"items\":[{\"text\":\"day-01 初识Node\",\"link\":\"/course/05-Node/day01/day01.md\"},{\"text\":\"day-02 模块化\",\"link\":\"/course/05-Node/day02/day02.md\"},{\"text\":\"day-03 Koa\",\"link\":\"/course/05-Node/day03/day03.md\"}]},{\"text\":\"Vue\",\"collapsed\":false,\"items\":[{\"text\":\"day-07 Vue-Router\",\"link\":\"/course/06-Vue/day07/day07.md\"},{\"text\":\"day-08 Vite-响应式\",\"link\":\"/course/06-Vue/day08/vue-2-8.md\"},{\"text\":\"day-09 H5-Vant上\",\"link\":\"/course/06-Vue/day09/day09-面经H5端-Vant上.md\"},{\"text\":\"day-10 H5-Vant下\",\"link\":\"/course/06-Vue/day10/day10-面经H5端-Vant下.md\"},{\"text\":\"day-11 Vuex\",\"link\":\"/course/06-Vue/day11/day11-vuex入门.md\"},{\"text\":\"day-12 PC-Element-UI上\",\"link\":\"/course/06-Vue/day12/day12-面经PC端-element上.md\"},{\"text\":\"day-13 PC-Element-UI下\",\"link\":\"/course/06-Vue/day13/day13-面经PC端-element下.md\"}]}],\"/2024/typescript/\":[{\"text\":\"typescript\",\"items\":[{\"text\":\"1. TS-数据类型\",\"link\":\"/2024/typescript/1. TS-数据类型\"},{\"text\":\"2. TS-接口\",\"link\":\"/2024/typescript/2. TS-接口\"},{\"text\":\"3. TS-类\",\"link\":\"/2024/typescript/3. TS-类\"},{\"text\":\"4. TS-函数\",\"link\":\"/2024/typescript/4. TS-函数\"}]}],\"/2024/vue/\":[{\"text\":\"vue2\",\"items\":[{\"text\":\"Object.defineProperty\",\"link\":\"/2024/vue/Object.defineProperty\"},{\"text\":\"Vue源码分析\",\"link\":\"/2024/vue/Vue源码分析\"},{\"text\":\"响应式原理\",\"link\":\"/2024/vue/响应式原理\"}]}]}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>