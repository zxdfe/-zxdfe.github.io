import{_ as e,c as i,o as a,a4 as s}from"./chunks/framework.C5O6QHj3.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"2024/computer-networks/11. Cookie Session JWT.md","filePath":"2024/computer-networks/11. Cookie Session JWT.md"}'),o={name:"2024/computer-networks/11. Cookie Session JWT.md"},t=s(`<h2 id="http是无状态的" tabindex="-1">HTTP是无状态的 <a class="header-anchor" href="#http是无状态的" aria-label="Permalink to &quot;HTTP是无状态的&quot;">​</a></h2><p><strong>HTTP 是无状态的</strong>。也就是说，HTTP 请求方和响应方间无法维护状态，都是一次性的，它不知道前后的请求都发生了什么。 但有的场景下，我们需要维护状态。最典型的，一个用户登陆微博，发布、关注、评论，都应是在登录后的用户状态下的。 要怎么维持这样的登录状态呢，Cookie 和 Session就是用来做这个滴~</p><hr><p><strong>HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息</strong>）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。 所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</p><h2 id="cookie" tabindex="-1">Cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;Cookie&quot;">​</a></h2><h3 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h3><p><strong>cookie 存储在客户端：</strong> cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。从而使服务器知道你曾经来过。Cookie 能够记录并保持诸如用户登录状态、购物车信息等各种状态信息。</p><hr><p><strong>cookie 是不可跨域的：</strong> 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，<strong>一级域名和二级域名之间是允许共享使用的</strong>（<strong>靠的是 domain）</strong></p><h3 id="cookie属性" tabindex="-1">Cookie属性 <a class="header-anchor" href="#cookie属性" aria-label="Permalink to &quot;Cookie属性&quot;">​</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/302528/1712734362806-430fdbd2-9848-4bab-bfce-3f94d9bb866a.png#averageHue=%23f8edbe&amp;clientId=u054ba167-28f6-4&amp;from=paste&amp;height=163&amp;id=u31068538&amp;originHeight=358&amp;originWidth=1686&amp;originalType=binary&amp;ratio=2.200000047683716&amp;rotation=0&amp;showTitle=false&amp;size=115781&amp;status=done&amp;style=none&amp;taskId=ud730e2b2-a98d-4073-8b91-e25f1b61c3e&amp;title=&amp;width=766.3636197531522" alt="image.png"><strong>Cookie</strong> 的重要属性有：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>Name</td><td>Cookie 的名称</td></tr><tr><td>Value</td><td>储存在 Cookie 中的字符串值, <strong>必须是字符串</strong></td></tr><tr><td><strong>Domain</strong></td><td>指定 cookie 所属域名，默认是当前域名</td></tr><tr><td><strong>Path</strong></td><td><strong>指定 cookie 在哪个路径（路由）下生效，默认是 &#39;/&#39;</strong>。</td></tr><tr><td>如果设置为 /abc，则只有 /abc 下的路由可以访问到该 cookie，如：/abc/read</td><td></td></tr><tr><td><strong>Expires/Max-Age</strong></td><td>这两个属性决定了 Cookie 的过期时间。</td></tr><tr><td><strong>Expires 指定了一个具体的过期时间</strong>（通常是一个固定的 UTC/GMT 时间）</td><td></td></tr><tr><td>Max-Age 接收一个以秒为单位的时长，完成和 Expires 同样的任务。<strong>如果不设置这两个值，那么 Cookie 则会在关闭浏览器会话时过期</strong></td><td></td></tr><tr><td>Secure</td><td>如果设置为 True，意味着 Cookie 只能通过 HTTPS 传输，在HTTP中无效</td></tr><tr><td><strong>HttpOnly</strong></td><td><strong>当此属性为真时，JS 中的 Document.cookie 的 API 无法获取到该 Cookie，<strong>可以一定程度上</strong>防止 XSS 攻击</strong></td></tr></tbody></table><p><strong>Domain</strong><code>**Domain**</code>标识指定了哪些主机可以访问该Cookie的域名。如果设置为.google.com，则所有以google.com结尾的域名都可以访问该Cookie。注意第一个字符为<code>.</code></p><p><strong>响应头写入Cookie</strong> HTTP 返回的一个 Set-Cookie 头用于向浏览器写入「一条（且只能是一条）」cookie，格式为 cookie 键值 + 配置键值。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Set-Cookie:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> username=zxd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; domain</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">zxdfe.com</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/blog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; Expires</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Wed,</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 21</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Oct</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2015</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 07:28:00</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> GMT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Secure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">HttpOnly</span></span></code></pre></div><p>注意，<code>Cookie的大小只有4k</code></p><h3 id="cookie-要注意哪些安全性" tabindex="-1">Cookie 要注意哪些安全性？ <a class="header-anchor" href="#cookie-要注意哪些安全性" aria-label="Permalink to &quot;Cookie 要注意哪些安全性？&quot;">​</a></h3><ul><li><code>cookie的value</code>如果用于保存用户登录态，应该将该值加密</li><li><code>http-only </code>属性设置了不能通过 JS 访问 Cookie，减少 XSS 攻击</li><li><code>Secure </code>属性设置只能在https请求中携带</li><li><code>SameSite </code>属性规定浏览器不能在跨域请求中携带 Cookie，减少 <code>CSRF </code>攻击</li></ul><h3 id="cookie的有效期" tabindex="-1">Cookie的有效期 <a class="header-anchor" href="#cookie的有效期" aria-label="Permalink to &quot;Cookie的有效期&quot;">​</a></h3><p>Cookie的有效期可以通过Expires和Max-Age两个属性来设置。</p><ul><li>Expires即过期时间</li><li>Max-Age用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算</li><li>过期时间如果<code>不设置</code>，或者为<code>负数或0</code>，关闭浏览器即销毁Cookie</li></ul><h2 id="session" tabindex="-1">Session <a class="header-anchor" href="#session" aria-label="Permalink to &quot;Session&quot;">​</a></h2><h3 id="基本概念-1" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念-1" aria-label="Permalink to &quot;基本概念&quot;">​</a></h3><ul><li>session 是另一种记录服务器和客户端会话状态的机制</li><li>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/302528/1712735987152-dcb7ca8d-a86d-4e74-b4ba-e29c87f3aa92.png#averageHue=%23d1c5c4&amp;clientId=u054ba167-28f6-4&amp;from=paste&amp;height=372&amp;id=u789cbbde&amp;originHeight=818&amp;originWidth=1396&amp;originalType=binary&amp;ratio=2.200000047683716&amp;rotation=0&amp;showTitle=false&amp;size=221810&amp;status=done&amp;style=none&amp;taskId=u8ffd3e7b-1842-493f-a3dd-2f234602108&amp;title=&amp;width=634.5454407920525" alt="image.png"></p><h3 id="典型的session登录验证流程" tabindex="-1">典型的session登录验证流程 <a class="header-anchor" href="#典型的session登录验证流程" aria-label="Permalink to &quot;典型的session登录验证流程&quot;">​</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/302528/1712736078996-46d16144-8624-4688-850c-8d0527db1260.png#averageHue=%23d9d9d9&amp;clientId=u054ba167-28f6-4&amp;from=paste&amp;height=434&amp;id=ud1f46f78&amp;originHeight=954&amp;originWidth=1546&amp;originalType=binary&amp;ratio=2.200000047683716&amp;rotation=0&amp;showTitle=false&amp;size=167420&amp;status=done&amp;style=none&amp;taskId=u4279ece5-5545-4a82-b8c8-0ab48d62d81&amp;title=&amp;width=702.7272574960696" alt="image.png"></p><ul><li>浏览器登录发送账号密码，服务器查数据库，校验用户，</li><li>服务端把用户登录状态存为 <code>Session</code>，生成一个 <code>sessionId</code></li><li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，响应头中Set-Cookie;</li><li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li><li>之后浏览器访问服务器的时候，SessionId 随 Cookie 带上；</li><li>服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找(校验)对应的 Session 信息，</li><li>如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li></ul><blockquote><p><strong>SessionID 是连接 Cookie 和 Session 的一道桥梁</strong></p></blockquote><h3 id="session的存储方式" tabindex="-1">Session的存储方式 <a class="header-anchor" href="#session的存储方式" aria-label="Permalink to &quot;Session的存储方式&quot;">​</a></h3><p>服务端只是给 cookie 一个 sessionId，而 session 的具体内容（可能包含用户信息、session 状态等），要后端自己存一下。 当前主要是将Session存在 Redis（推荐）中， 当然也可以存普通数据库，性能不高</p><h3 id="cookie和session的区别" tabindex="-1">Cookie和Session的区别 <a class="header-anchor" href="#cookie和session的区别" aria-label="Permalink to &quot;Cookie和Session的区别&quot;">​</a></h3><p>Cookie 和 Session 都是为了解决 HTTP 协议无状态性的问题而产生的。详细的区别如下：</p><ol><li><strong>存储位置</strong></li></ol><ul><li><strong>Cookie</strong> 数据存储在客户的浏览器上</li><li><strong>Session</strong> 数据存储在服务器上</li></ul><ol start="2"><li><strong>数据安全性</strong></li></ol><ul><li><strong>Cookie</strong> 存储在客户端，数据相对容易被篡改，不是完全安全</li><li><strong>Session</strong> 存储在服务器，安全性较好</li></ul><ol start="3"><li><strong>生命周期</strong></li></ol><ul><li><strong>Cookie</strong> 的生命周期由 Expires 或 Max-Age 属性决定，如果没有设置，Cookie 在浏览器关闭时就会失效（此时sessionId也找不到了，会话session）</li><li><strong>Session</strong> 通常有较短的生命周期，用户关闭浏览器或长时间不活动（根据服务器配置）则会过期</li></ul><ol start="4"><li><strong>对服务器压力</strong></li></ol><ul><li><strong>Cookie</strong> 存储在客户端，对服务器性能无影响</li><li><strong>Session</strong> 存储在服务器端，如果数据过大或过多，会对服务器性能产生影响</li></ul><ol start="5"><li><strong>存储大小</strong></li></ol><ul><li><strong>Cookie</strong> 的大小限制在4KB左右</li><li><strong>Session</strong> 存储在服务器端，如果数据过大或过多，可能会对服务器性能产生影响</li></ul><ol start="6"><li><strong>跨域问题</strong></li></ol><ul><li><strong>Cookie</strong> 的跨域需要一定的设置，但实现相对复杂 <ul><li>服务器设置响应头:<code>Access-Control-Allow-Origin / Access-Control-Allow-Credentials</code></li><li>客户端配置：<code>withCredentials : true</code></li></ul></li><li><strong>Session</strong> 要实现跨域也需要相应的配置并结合其他手段，如跨域共享 Session，实现也较为复杂</li></ul><h2 id="token" tabindex="-1">Token <a class="header-anchor" href="#token" aria-label="Permalink to &quot;Token&quot;">​</a></h2><p>session 的维护给服务端造成很大困扰，我们必须找地方存放它，又要考虑分布式的问题，甚至要单独为了它启用一套 Redis 集群。有没有更好的办法？使用Token（令牌）</p><h3 id="token流程" tabindex="-1">token流程 <a class="header-anchor" href="#token流程" aria-label="Permalink to &quot;token流程&quot;">​</a></h3><p>在前后端通信时，Token 可以通过两种常用方式发送给后端：<code>HTTP Header 和 Cookie</code>。</p><h4 id="随cookie请求带上token的方式" tabindex="-1">随Cookie请求带上Token的方式 <a class="header-anchor" href="#随cookie请求带上token的方式" aria-label="Permalink to &quot;随Cookie请求带上Token的方式&quot;">​</a></h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/302528/1712737430720-f7337ced-1567-40c9-b9a3-30c53caf460c.png#averageHue=%23dfdfdf&amp;clientId=u054ba167-28f6-4&amp;from=paste&amp;height=607&amp;id=u1b6192c4&amp;originHeight=1336&amp;originWidth=1638&amp;originalType=binary&amp;ratio=2.200000047683716&amp;rotation=0&amp;showTitle=false&amp;size=229351&amp;status=done&amp;style=none&amp;taskId=u7da18e7d-031f-4dbf-85a1-d1a07f4f0cb&amp;title=&amp;width=744.5454384078668" alt="image.png"></p><ul><li>用户登录，服务端校验账号密码，获得用户信息</li><li>把用户信息、time、sign等配置编码生成token，通过 cookie set 返回到浏览器 <ul><li>也可以直接通过接口返回，同时浏览器也可以把token存其他地方，比如localStorage</li></ul></li><li>此后用户请求业务接口，通过 cookie 携带 token <ul><li><strong>更推荐的做法是将Token放到Header中</strong></li></ul></li><li>接口校验 token 有效性，进行正常业务接口处理</li></ul><hr><p>把 token 存储在 Cookie 中。服务器通过 Set-Cookie 响应头设置 Cookie，然后在每次请求时，浏览器都会自动带上 Cookie 发送给服务器。</p><h4 id="将token放到请求头中" tabindex="-1">将Token放到请求头中 <a class="header-anchor" href="#将token放到请求头中" aria-label="Permalink to &quot;将Token放到请求头中&quot;">​</a></h4><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;api/user&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  headers: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;Authorization&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Bearer &#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> token</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>这种方法的优点是</p><ol><li>可以<code>手动控制何时发送 token</code>，使得前后端交互更灵活。</li><li>同时，因为 <code>token 并不在 Cookie 中，避免了 CSRF 攻击</code>。</li></ol><hr><h3 id="refresh-token" tabindex="-1">Refresh Token <a class="header-anchor" href="#refresh-token" aria-label="Permalink to &quot;Refresh Token&quot;">​</a></h3><p><code>业务接口用来鉴权的 token，我们称之为 Access token</code>。越是权限敏感的业务，我们越希望 access token 有效期足够短，以避免被盗用。但过短的有效期会造成 access token 经常过期，过期后怎么办呢？ 一种办法是，让用户重新登录获取新 token，显然不够友好，要知道有的 access token 过期时间可能只有几分钟。 另外一种办法是，再来一个 token，<code>一个专门用于生成（刷新） Access token 的 token，我们称为 refresh token。</code> 有了 refresh token 后，请求流程变成这样： <img src="https://cdn.nlark.com/yuque/0/2024/webp/302528/1712739027313-9c7ef6a9-988f-4a6c-a3dc-3ffdb36f145c.webp#averageHue=%23f8f8f8&amp;clientId=u054ba167-28f6-4&amp;from=drop&amp;id=u3eb6c62c&amp;originHeight=1631&amp;originWidth=1512&amp;originalType=binary&amp;ratio=2.200000047683716&amp;rotation=0&amp;showTitle=false&amp;size=52588&amp;status=done&amp;style=none&amp;taskId=u6b642070-3cef-4d4c-95c6-7fcf1a19dc5&amp;title=" alt="b764b256211b4ea182388fd92674fe70~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp"></p><ul><li>Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token（Access Token），如果 Refresh Token 也失效了，用户就只能重新登录了。</li><li>在一种常见的设计策略中，<code>Refresh Token只能使用一次，使用后会被销毁，并产生一个新的Refresh Token一起返回给客户端</code>。这种策略的好处是如果Refresh Token被泄露并被使用，正常用户在使用旧的Refresh Token获取新的Access Token时会发现无法使用，从而可能提早发现Token的泄露。</li></ul><h3 id="token-和-session的区别" tabindex="-1">Token 和 Session的区别 <a class="header-anchor" href="#token-和-session的区别" aria-label="Permalink to &quot;Token 和 Session的区别&quot;">​</a></h3><ol><li><strong>存放位置：</strong><ul><li><code>Session</code>：Session 数据存储在服务器端，客户端的请求会带上 Session ID，服务器根据 Session ID 在内存或者数据库中查到保存的状态信息。</li><li><code>Token </code>：Token 数据存储在客户端（通常在 Cookie、LocalStorage 或 sessionStorage 中），每次请求会将其送至服务器端验证。</li></ul></li><li><strong>状态：</strong><ul><li>Session：是有状态的，服务器需要保存每个用户的 Session 数据。</li><li>Token ：是无状态的，服务器不保存用户状态，每次请求都会携带验证信息（Token）。这使得 Token 可以做到跨平台和跨域。</li></ul></li><li><strong>数据安全：</strong><ul><li>Session：数据存储在服务器端，相对比较安全，但是如果 Session ID 泄露可能会带来安全问题。</li><li>Token ：Token 需要传输的数据可能处于非常开放的环境，容易被截取，需要通过算法进行加解密。</li></ul></li><li><strong>扩展性：</strong><ul><li>Session：Session 存储在服务器，可能会对服务器资源造成压力，尤其在大规模分布式系统、负载均衡等环境下，处理 Session 变得复杂。</li><li>Token ：由于无状态、分离了服务器和认证，使得系统拓展性更强。</li></ul></li></ol><h2 id="jwt" tabindex="-1">JWT <a class="header-anchor" href="#jwt" aria-label="Permalink to &quot;JWT&quot;">​</a></h2><h3 id="基本" tabindex="-1">基本 <a class="header-anchor" href="#基本" aria-label="Permalink to &quot;基本&quot;">​</a></h3><p>JSON Web Token（简称 JWT）是目前最流行的<strong>跨域认证</strong>解决方案</p><ul><li>是一种<code>认证授权机制</code></li><li><strong>JWT 是一种具体的 Token 生成和验证标准</strong></li></ul><hr><p>一个 JWT 通常由三部分构成：<code>header（头部）</code>, <code>payload（负载）</code> 和 <code>signature（签名）</code></p><ol><li>Header（头部）： <ol><li>指定了 token 的类型（即 JWT）和所使用的签名算法，如 HMAC、SHA256 或 RSA。</li></ol></li><li>Payload（负载）： <ol><li>存放了实际需要传递的数据，如用户名、用户角色等。</li></ol></li><li>Signature（签名）： <ol><li>对 header 和 payload 的数据进行签名，确保数据不被篡改。</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/302528/1712740798553-320ce672-ab87-4529-af52-b07352280a43.png#averageHue=%23e5e5e5&amp;clientId=u054ba167-28f6-4&amp;from=paste&amp;height=417&amp;id=ue77e0fb3&amp;originHeight=918&amp;originWidth=1650&amp;originalType=binary&amp;ratio=2.200000047683716&amp;rotation=0&amp;showTitle=false&amp;size=351337&amp;status=done&amp;style=none&amp;taskId=u1b0f3474-0538-4820-a185-35bb0be26d2&amp;title=&amp;width=749.9999837441882" alt="image.png"> JWT 可以用于各种场景，比如：</p><ul><li><code>身份验证：</code>服务器在验证用户登录后，生成 JWT 返回给客户端。以后客户端的每个请求都包含这个 JWT，服务器就可以通过验证 JWT 来确认这个请求是合法的。</li><li><code>信息交换：</code>JWT 可以在各个服务之间安全地传递信息，因为 JWT 是签名的，所以接收方可以验证这个 JWT 是由真正可信的一方发送的。</li></ul><hr><ul><li><a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noreferrer">JSON Web Token 入门教程 - 阮一峰的网络日志</a></li><li><a href="https://datatracker.ietf.org/doc/html/rfc7519" target="_blank" rel="noreferrer">RFC 7519: JSON Web Token (JWT)</a></li><li><a href="https://zhuanlan.zhihu.com/p/86937325" target="_blank" rel="noreferrer">五分钟带你了解啥是JWT</a></li><li><a href="https://cloud.tencent.com/developer/article/1886353" target="_blank" rel="noreferrer">什么是 JWT -- JSON WEB TOKEN-腾讯云开发者社区-腾讯云</a></li><li><a href="https://jwt.io/" target="_blank" rel="noreferrer">https://jwt.io/</a></li><li><a href="https://jwt.io/introduction" target="_blank" rel="noreferrer">https://jwt.io/introduction</a></li></ul><h3 id="jwt认证流程" tabindex="-1">JWT认证流程 <a class="header-anchor" href="#jwt认证流程" aria-label="Permalink to &quot;JWT认证流程&quot;">​</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/302528/1712740209656-498dd4fa-2f40-492d-982b-8dc32ae120a4.png#averageHue=%23d3d3d3&amp;clientId=u054ba167-28f6-4&amp;from=paste&amp;height=410&amp;id=uacff8556&amp;originHeight=902&amp;originWidth=1364&amp;originalType=binary&amp;ratio=2.200000047683716&amp;rotation=0&amp;showTitle=false&amp;size=201793&amp;status=done&amp;style=none&amp;taskId=u506de21d-b8e7-4d83-b2b7-5c1518ce793&amp;title=&amp;width=619.9999865618622" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/302528/1712740665643-3cd56661-69dc-478d-ad2a-5e3db24b8311.png#averageHue=%23dedede&amp;clientId=u054ba167-28f6-4&amp;from=paste&amp;height=471&amp;id=uc5da645c&amp;originHeight=1036&amp;originWidth=1914&amp;originalType=binary&amp;ratio=2.200000047683716&amp;rotation=0&amp;showTitle=false&amp;size=238485&amp;status=done&amp;style=none&amp;taskId=udafee434-baa0-46b3-ad55-84cc3ff854e&amp;title=&amp;width=869.9999811432582" alt="image.png"></p><ul><li>用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT</li><li>客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）</li><li>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是下面这样</li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Authorization: Bearer &lt;</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">token</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><ul><li>服务器检测JWT信息，如果合法，则允许用户行为</li><li>因为JWT不使用Cookie，所以可以向任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li><li>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制</li></ul><h3 id="jwt的使用方式" tabindex="-1">JWT的使用方式 <a class="header-anchor" href="#jwt的使用方式" aria-label="Permalink to &quot;JWT的使用方式&quot;">​</a></h3><h4 id="http请求头中" tabindex="-1">HTTP请求头中 <a class="header-anchor" href="#http请求头中" aria-label="Permalink to &quot;HTTP请求头中&quot;">​</a></h4><p>当用户希望访问一个受保护的路由或者资源的时候，可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GET</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">calendar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">v1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">events</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Host</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: api.example.com</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Authorization</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Bearer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">token</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><h4 id="post请求体中" tabindex="-1">POST请求体中 <a class="header-anchor" href="#post请求体中" aria-label="Permalink to &quot;POST请求体中&quot;">​</a></h4><ul><li>跨域的时候，可以把 JWT 放在 POST 请求的数据体里。</li></ul><h4 id="url拼接" tabindex="-1">URL拼接 <a class="header-anchor" href="#url拼接" aria-label="Permalink to &quot;URL拼接&quot;">​</a></h4><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">http://www.example.com/user?token</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=xxx</span></span></code></pre></div><h3 id="常见的前后端鉴权方式" tabindex="-1">常见的前后端鉴权方式 <a class="header-anchor" href="#常见的前后端鉴权方式" aria-label="Permalink to &quot;常见的前后端鉴权方式&quot;">​</a></h3><ol><li>Session-Cookie</li><li>Token 验证（包括 JWT，SSO）</li><li>OAuth2.0（开放授权）</li></ol><h2 id="单点登录" tabindex="-1">单点登录 <a class="header-anchor" href="#单点登录" aria-label="Permalink to &quot;单点登录&quot;">​</a></h2><p>参考：<a href="https://juejin.cn/post/6898630134530752520?searchId=202404101055040B640732313D5C73B0EE#heading-6" target="_blank" rel="noreferrer">前端鉴权的兄弟们：cookie、session、token、jwt、单点登录 - 掘金</a></p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><p><a href="https://juejin.cn/post/6844904034181070861?searchId=202404101055040B640732313D5C73B0EE#heading-32" target="_blank" rel="noreferrer">傻傻分不清之 Cookie、Session、Token、JWT - 掘金</a><a href="https://juejin.cn/post/6898630134530752520?searchId=202404101055040B640732313D5C73B0EE#heading-6" target="_blank" rel="noreferrer">前端鉴权的兄弟们：cookie、session、token、jwt、单点登录 - 掘金</a></p>`,94),n=[t];function l(r,h,p,d,k,c){return a(),i("div",null,n)}const u=e(o,[["render",l]]);export{m as __pageData,u as default};
