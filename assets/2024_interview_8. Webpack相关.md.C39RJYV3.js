import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.Mj8dOX4M.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"2024/interview/8. Webpack相关.md","filePath":"2024/interview/8. Webpack相关.md"}'),l={name:"2024/interview/8. Webpack相关.md"},p=n(`<h2 id="webpack的构建流程" tabindex="-1">webpack的构建流程？ <a class="header-anchor" href="#webpack的构建流程" aria-label="Permalink to &quot;webpack的构建流程？&quot;">​</a></h2><ol><li><strong>初始化：</strong><ol><li>从配置文件和 Shell 语句中读取与合并配置参数</li><li>初始化<code>Compiler对象</code>，遍历配置中的<code>plugins集合</code>，执行插件的<code>apply方法</code><ol><li>apply方法其实就是插件的初始化，注册插件到Webpack的各个生命周期钩子函数上</li></ol></li></ol></li><li><strong>编译阶段：</strong><ol><li>根据配置中的<code>entry</code>找出所有的入口模块（文件），模块ID就是文件的路径</li><li><code>从entry文件开始</code>，调用所有配置的 Loader 将模块转译为webpack能识别的JS代码，之后转为AST结构，遍历AST从中找出该模块依赖的模块；</li><li>之后递归遍历所有依赖模块，找出依赖的依赖，直至遍历完所有项目资源后，构建出完整的<code>模块依赖关系图</code></li></ol></li><li><strong>输出资源</strong><ol><li>根据入口和模块之间的依赖关系，将编译完成的模块组合成一个个代码块 chunk，将多个 chunk 合并为一个文件，过程中可能会进行代码拆分和文件合并</li><li>根据 output 参数，确定输出的路径和文件名，把文件内容写入到文件系统</li></ol></li></ol><hr><p>简单来说</p><ul><li>初始化：合并参数，实例化 Compiler，注册Plugin</li><li>编译：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li><li>输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中</li></ul><hr><p>当Webpack调用 apply 方法时，插件通常会做以下两个工作：</p><ol><li>定义一个钩子函数（hook）用来做一些特定的工作。</li><li>把这个钩子函数注册到Webpack的具体编译阶段。</li></ol><p>compiler.hooks.emit.tap 的作用就是把一个回调函数注册到对应 emit 阶段，当Webpack编译到这个阶段时，就会执行这个钩子函数。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">compiler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    compiler.hooks.emit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;MyPlugin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">compilation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 在 emit 阶段做一些事情...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="有哪些常见loader、plugin" tabindex="-1">有哪些常见loader、plugin <a class="header-anchor" href="#有哪些常见loader、plugin" aria-label="Permalink to &quot;有哪些常见loader、plugin&quot;">​</a></h2><ul><li>style-loader</li><li>css-loader</li><li>sass-loader</li><li>vue-loader</li></ul><hr><ul><li>html-webpack-plugin</li><li>terser-webpack-plugin</li><li>speed-measure-webpack-plugin</li><li>webpack-bundle-analyzer</li></ul><h2 id="loader和-plugin的区别" tabindex="-1">Loader和 Plugin的区别？ <a class="header-anchor" href="#loader和-plugin的区别" aria-label="Permalink to &quot;Loader和 Plugin的区别？&quot;">​</a></h2><p><code>Loader 本质就是一个函数</code>，这个函数接收<code>源文件的内容</code>作为参数，对这个内容进行处理，然后返回一个有效的 JavaScript 模块。 Loader 就像一个“翻译员”，将某种语言（类型的文件）翻译（转换）成 JavaScript，从而让 webpack 能够识别并且处理。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// loader</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">source</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(source);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> source;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p><code>Plugin 本质上是一个拥有 apply 方法的类；</code> 基于Tapable的事件流机制，Plugin 可以让我们在 webpack 的生命周期的特定时刻插入一些自定义行为，</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">compiler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    compiler.hooks.done.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;My Plugin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">stats</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;MyPlugin: done&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="文件指纹是什么-怎么用的" tabindex="-1">文件指纹是什么？怎么用的 <a class="header-anchor" href="#文件指纹是什么-怎么用的" aria-label="Permalink to &quot;文件指纹是什么？怎么用的&quot;">​</a></h2><p>文件指纹常<code>用于处理静态资源的缓存问题</code>。每当文件内容改变时，文件指纹也会随之改变。文件指纹通常是通过对<code>文件内容进行哈希（Hashing）计算得来的</code>。</p><ol><li><code>[hash]</code>：<strong>基于每次项目构建的哈希值</strong>，当项目文件有任何改动，整个项目构建的哈希值就会变化。</li><li><code>[chunkhash]</code>：<strong>基于每个 chunk 的内容生成的哈希值</strong>，只有所属 chunk 内容改变时，哈希值才会变化，适合用在生产环境对 js 文件进行指纹设置。</li><li><code>[contenthash]</code>：<strong>根据文件内容生成的哈希值</strong>，适合用在生产环境对 css 文件进行指纹设置。</li></ol><hr><h3 id="js文件指纹设置" tabindex="-1">JS文件指纹设置 <a class="header-anchor" href="#js文件指纹设置" aria-label="Permalink to &quot;JS文件指纹设置&quot;">​</a></h3><blockquote><p>JS ==&gt; <code>chunkhash</code></p></blockquote><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  output: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    filename: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;[name].[chunkhash].js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    path: path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__dirname, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;dist&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h3 id="css文件指纹位置" tabindex="-1">CSS文件指纹位置 <a class="header-anchor" href="#css文件指纹位置" aria-label="Permalink to &quot;CSS文件指纹位置&quot;">​</a></h3><blockquote><p>CSS ==&gt; contenthash</p></blockquote><p>首先需要使用 MiniCssExtractPlugin 插件来提取 CSS 为单独的文件，然后在设置 filename 时使用 [contenthash]：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MiniCssExtractPlugin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;mini-css-extract-plugin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  plugins: [</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MiniCssExtractPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // CSS文件指纹</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      filename: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;[name].[contenthash].css&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  module: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rules: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        test:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\.</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">css</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        use: [MiniCssExtractPlugin.loader, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;css-loader&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h2 id="compiler-和-compilation-的区别" tabindex="-1">Compiler 和 <strong>Compilation 的区别</strong> <a class="header-anchor" href="#compiler-和-compilation-的区别" aria-label="Permalink to &quot;Compiler 和 **Compilation 的区别**&quot;">​</a></h2><h3 id="compiler" tabindex="-1">Compiler <a class="header-anchor" href="#compiler" aria-label="Permalink to &quot;Compiler&quot;">​</a></h3><p>一个Webpack配置文件对应一个Compiler实例 Compiler 对象表示了Webpack从启动到关闭的整个生命周期。在编译过程中，Compiler 会统一管理所有的配置，包括但不限于选项（options）、loader、plugin等</p><h3 id="compilation" tabindex="-1">Compilation <a class="header-anchor" href="#compilation" aria-label="Permalink to &quot;Compilation&quot;">​</a></h3><p>Compilation 对象表示了一次新的编译过程。 在开发模式下，每当文件发生变化时，Webpack会创建一个新的 Compilation 实例重新编译代码。</p><hr><ul><li>Compiler 是全局唯一的，代表了整个Webpack生命周期</li><li>而 Compilation 则代表了一次单独的编译过程。所以在项目的构建过程中，Compiler 只会有一个，而 Compilation 会有多个。</li></ul><h2 id="webpack的-热更新-hmr-原理" tabindex="-1">webpack的 热更新（HMR）原理 <a class="header-anchor" href="#webpack的-热更新-hmr-原理" aria-label="Permalink to &quot;webpack的 热更新（HMR）原理&quot;">​</a></h2><p>Webpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。</p><blockquote><p>流程==&gt;</p></blockquote><ol><li><code>启动DevServer：</code> 使用<code>webpack-dev-server（WDS）</code>启动应用托管静态资源，并且DevServer会向html注入一段处理HMR逻辑的客户端代码。</li><li><strong>建立连接</strong>：浏览器加载页面后，与 WDS 建立 WebSocket 连接</li><li>**监听文件变化： **Webpack 监听到文件变化后，增量构建发生变更的模块，打包成一个或多个热更新Chunk</li><li>**发送更新 ： **模块构建好后，WDS会通过之前建立的WebSocket连接向客户端发送包含本次构建时的hash，让客户端与上一次资源进行对比</li><li><strong>加载更新</strong>: 客户端收到hash事件，对比差异后，会向WDS发送Ajax请求，去下载发生变更的增量模块。</li><li><strong>热替换</strong>：Webpack 运行时触发变更模块的 module.hot.accept 回调，执行代码变更逻辑；</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/302528/1712848609889-1607d17c-aa13-4d9d-9922-f80313bf9859.png#averageHue=%23d6c6ac&amp;clientId=u9bcafa88-afdd-4&amp;from=paste&amp;height=423&amp;id=udfb1fd18&amp;originHeight=930&amp;originWidth=1478&amp;originalType=binary&amp;ratio=2.200000047683716&amp;rotation=0&amp;showTitle=false&amp;size=269468&amp;status=done&amp;style=none&amp;taskId=u3a083a61-5766-465c-8516-546733f4fe1&amp;title=&amp;width=671.8181672569152" alt="image.png"></p><h2 id="babel的原理" tabindex="-1">Babel的原理 <a class="header-anchor" href="#babel的原理" aria-label="Permalink to &quot;Babel的原理&quot;">​</a></h2><p>Babel 是一个广泛使用的 JavaScript 编译器，作用是把开发者写的最新标准的 JavaScript 代码转化为旧版本的 JavaScript 语法，从而可以在当前浏览器或者旧版本的 NodeJs 环境中运行。Babel 大概的工作原理如下：</p><hr><p>Babel 的编译过程主要包含三个阶段：<strong>解析（Parsing）、转化（Transforming）和生成（Generating）。</strong></p><hr><p><strong>解析阶段：</strong> 在解析阶段，Babel 把源码转化为抽象语法树（Abstract Syntax Tree，AST）。 <strong>转化阶段：</strong> 这个阶段是 Babel 的核心阶段，它会遍历抽象语法树上所有的节点，并应用一系列的插件（譬如 ES6 语法插件、JSX语法插件等）逐个对节点进行转化或者替换。比如说，如果一段代码中使用了箭头函数，Babel 就会在这个阶段将箭头函数的节点替换为函数表达式的节点。 <strong>生成阶段：</strong> 在这个阶段，Babel 会把经过转化的抽象语法树重新生成为 JavaScript 代码。这一步也叫做代码生成。这个过程中，Babel 会尽可能地保留源代码中的格式，包括空格、逗号等，如果无法保留，就会使用默认的格式。</p><h2 id="是否写过plugin-简单描述一下编写plugin的思路" tabindex="-1">是否写过Plugin？简单描述一下编写Plugin的思路？ <a class="header-anchor" href="#是否写过plugin-简单描述一下编写plugin的思路" aria-label="Permalink to &quot;是否写过Plugin？简单描述一下编写Plugin的思路？&quot;">​</a></h2><p>首先我们使用的时候，**实例化了一个插件对象（new Plugin），**所以要编写的插件是需要定义成一个类的，并且它的原型上需要定义一个<code>apply方法</code>。 apply方法会在插件安装的时候执行一次，相当于事件绑定一样，监听特定的时机让我们可以做一些自定义行为。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HelloWorldPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">compiler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    compiler.hooks.done.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &#39;Hello World Plugin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        stats </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* stats is passed as an argument when done hook is tapped.  */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      ) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello World!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HelloWorldPlugin;</span></span></code></pre></div><p>然后，开发插件时最重要的两个资源是<code>compiler</code>和<code>compilation</code>对象。它们是 Plugin 和 Webpack 之间的桥梁。</p><ul><li><strong>Compiler 对象包含了 Webpack 环境所有的的配置信息</strong>，包含 options，loaders，plugins 这些信息，这个对象在 Webpack 启动时候被实例化，它是全局唯一的，可以简单地把它理解为 Webpack 实例；</li><li>Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。当 Webpack 以开发模式运行时，每当检测到一个文件变化，一次新的 Compilation 将被创建。</li><li>传给每个插件的 Compiler 和 Compilation 对象都是同一个引用。也就是说在一个插件中修改了 Compiler 或 Compilation 对象上的属性，会影响到后面的插件</li></ul><hr><ul><li>我们在apply方法中，指定要用到的事件钩子，然后自定义一些操作。那如果是异步操作，比如tapAsync，在功能完成后调用 webpack 提供的回调</li></ul><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// A JavaScript class.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyExampleWebpackPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Define \`apply\` as its prototype method which is supplied with compiler as its argument</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">compiler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Specify the event hook to attach to</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    compiler.hooks.emit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tapAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &#39;MyExampleWebpackPlugin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">compilation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;This is an example plugin!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">          &#39;Here’s the \`compilation\` object which represents a single build of assets:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          compilation</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        );</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Manipulate the build using the plugin API provided by webpack</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        compilation.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="webpack性能优化" tabindex="-1">webpack性能优化 <a class="header-anchor" href="#webpack性能优化" aria-label="Permalink to &quot;webpack性能优化&quot;">​</a></h2><p><a href="https://juejin.cn/post/7083519723484708878?searchId=20240319214738C59160AF9CCD42D54D73#heading-15" target="_blank" rel="noreferrer">每个前端都必须要学会的Webpack优化手段 - 掘金</a><a href="https://juejin.cn/post/6844903651291447309?searchId=20240319214738C59160AF9CCD42D54D73" target="_blank" rel="noreferrer">三十分钟掌握Webpack性能优化 - 掘金</a><a href="https://juejin.cn/post/7186315052465520698?searchId=20240319214738C59160AF9CCD42D54D73" target="_blank" rel="noreferrer">前端性能优化——包体积压缩82%、打包速度提升65% - 掘金</a><a href="https://juejin.cn/post/6844904071736852487?searchId=20240319214738C59160AF9CCD42D54D73" target="_blank" rel="noreferrer">玩转 webpack，使你的打包速度提升 90% - 掘金</a><a href="https://juejin.cn/post/6844904093463347208?searchId=20240319214738C59160AF9CCD42D54D73" target="_blank" rel="noreferrer">带你深度解锁Webpack系列(优化篇) - 掘金</a></p><blockquote><p>使用webpack-bundle-analyzer可以审查打包后的体积分布，进而进行相应的体积优化</p></blockquote><h3 id="优化构建速度" tabindex="-1">优化构建速度 <a class="header-anchor" href="#优化构建速度" aria-label="Permalink to &quot;优化构建速度&quot;">​</a></h3><ol><li>**HappyPack/ thread-loader **多进程打包，可以大大提高构建的速度，</li><li><strong>优化loader配置，cache-loader（w4）</strong></li><li><strong>启用持久化</strong>缓存，提高增量构建的速度</li></ol><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// webpack5 </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 其他配置项...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  cache: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;filesystem&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &#39;memory&#39; for in-memory caching</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="4"><li>**缩小打包作用域exclude&amp;include **合理配置这两个属性，大大提高构建速度</li><li>开发环境，开启热更新HMR</li><li>使用高版本的Webpack 和 Node.js</li></ol><h3 id="减少打包体积" tabindex="-1">减少打包体积 <a class="header-anchor" href="#减少打包体积" aria-label="Permalink to &quot;减少打包体积&quot;">​</a></h3><ol><li>CSS - css-minimizer-webpack-plugin 代码压缩</li><li>JS - terser-webpack-plugin JS代码压缩</li><li>使用 Tree-shaking 剔除无用代码（webpack5默认开启）</li><li>组件库按需引入，</li><li>开启 Gzip 压缩</li><li>使用dayjs替换moment.js</li><li>使用Scope Hoisting（w5默认启用）（记得禁用Babel的模块编译）</li><li>使用 base64 编码减少体积</li><li>图片压缩 <code>image-minimizer-webpack-plugin </code>(无损)</li></ol><h3 id="优化加载性能-提升-优化-用户体验" tabindex="-1">优化加载性能，提升（优化）用户体验 <a class="header-anchor" href="#优化加载性能-提升-优化-用户体验" aria-label="Permalink to &quot;优化加载性能，提升（优化）用户体验&quot;">​</a></h3><ol><li>按需加载（懒加载）配置</li><li>使用魔法注释对某些模块开启prefetch和preload</li></ol><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 预加载</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* webpackPreload: true */</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;LazyComponent&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 预获取 （下一个页面，页面空闲的时候获取）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* webpackPrefetch: true */</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;LazyComponent&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><ol start="3"><li>Code Splitting:将代码拆分成多个块（chunks）以减少初始加载时间和提高页面加载速度。</li></ol><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// webpack.config.js</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  optimization: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    splitChunks: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      chunks: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;all&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 指定最小大小，小于此尺寸的模块，将不会被拆分</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      minSize: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 最大尺寸，用于限制合成块的最大尺寸。优化以达到更好的缓存效果</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      maxSize: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 最小 chunk 引用次数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      minChunks: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 最大异步请求 chunks 数，设置后并行加载的最大数量将会更小</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      maxAsyncRequests: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 最大初始化加载 chunk 数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      maxInitialRequests: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 分割块之间彼此连接的字符，例如 vendors~main.js</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      automaticNameDelimiter: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;~&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 打包策略</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      cacheGroups: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        vendors: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          test:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\\\</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">/]</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">node_modules</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\\\</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">/]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          priority: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        default: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          minChunks: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          priority: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 如果当前块包含已经从主 bundle 中拆分出来的模块，则重用该模块，不会再重新生成一个新的模块</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          reuseExistingChunk: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="4"><li>开启 Gzip 压缩</li><li>基础依赖使用CDN引入<code>externals配置</code></li></ol><div class="language-tsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  externals: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;vue-router&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;VueRouter&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 从HTML标签中引入这些CDN库</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://cdn.jsdelivr.net/npm/vue-router/dist/vue-router.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><ol start="6"><li>开启文件名 hash <code>filename: &#39;js/chunk-[contenthash].js&#39;</code><ol><li>改过的文件需要更新hash值，而没改过的文件依然保持原本的hash值，这样才能保证在上线后，浏览器访问时没有改变的文件会命中缓存，从而达到性能优化的目的</li></ol></li></ol><h2 id="提高首页加载速度-可以怎么优化" tabindex="-1">提高首页加载速度，可以怎么优化 <a class="header-anchor" href="#提高首页加载速度-可以怎么优化" aria-label="Permalink to &quot;提高首页加载速度，可以怎么优化&quot;">​</a></h2><ol><li><strong>使用资源压缩</strong>：使用 gzip对资源进行压缩，可以有效减少资源的体积，缩短网络传输时间。</li><li><strong>压缩和优化图片</strong>：对于大尺寸、大体积的图片，可以考虑使用 WebP 或者压缩工具进行优化。</li><li><strong>利用 CDN</strong>：使用内容分发网络（Content Delivery Network，CDN）能够加速资源的加载速度，特别是对地理位置远离服务器的用户能够提供好的访问体验。</li><li><strong>代码分割 Code Splitting</strong>：对代码进行分割，只加载当前页面真正需要的脚本和样式，可以明显提高网页的初次加载速度。</li><li><strong>服务端配置开启HTTP/2</strong>：相较于 HTTP/1，HTTP/2 支持多路复用，同时处理多个请求，能够显著减少网页加载时间。</li><li><strong>预加载/预读取 Preload/Prefetch</strong>：可用于某些未来会用到的资源，使其提前加载，达到优化的效果。</li><li><strong>Tree Shaking</strong>：这是一种只打包引用到的模块的方法，未引用到的模块不会被包含在最终的 bundle 中，可以减少JavaScript的体积。</li><li><strong>缓存优化</strong>：你可以使用 cache-control、ETag、last-modified 等HTTP缓存控制头来优化缓存，避免不必要的请求。</li><li><strong>Lazy Loading</strong>：懒加载是一种只有当资源需要运行或者需要显示在屏幕上时才加载的策略。对于图片、组件、路由等都可以进行懒加载。</li><li><strong>使用骨架屏（Skeleton Screen）</strong>：骨架屏是一种优化首屏白屏的 UI 设计模式，它先显示一个与最终页面类似的空白版本，随后通过懒加载的方式，当页面内容渲染完成后再替换骨架屏。这样用户会有内容正在加载的感知。</li><li><strong>服务端渲染 (SSR)</strong>：服务端渲染可以使得用户在首次请求时就可以获取到完整的 HTML 页面，避免白屏的出现。对于 JavaScript-heavy 的应用（如React、Vue等），服务端渲染是一种有效的优化策略。</li><li><strong>Lighthouse、Webpack Bundle Analyzer</strong>等工具进行性能分析和优化</li></ol><h2 id="vite为什么比webpack快" tabindex="-1">Vite为什么比Webpack快？ <a class="header-anchor" href="#vite为什么比webpack快" aria-label="Permalink to &quot;Vite为什么比Webpack快？&quot;">​</a></h2><ol><li>快速的冷启动: Vite 使用<code> esbuild（go） 预构建依赖</code>, 并且<code>以原生 ESM 方式提供源码，让浏览器接管了打包程序的部分工作</code>：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。</li><li><code>高效的热更新:</code> Vite的热更新HMR 是在原生 ESM 上执行的，无论应用大小如何，HMR 始终能保持快速更新。并且<strong>Vite增加了缓存策略：源码模块使用304协商缓存，依赖模块使用cache-control强缓存</strong></li><li><code>基于Rollup打包</code>：Rollup 针对 ESM 的 tree-shaking 操作更加高效，可以清除更多无效的冗余代码。</li></ol><h2 id="vite的hrm热更新和webpack-hmr的有什么不同" tabindex="-1">Vite的HRM热更新和webpack HMR的有什么不同？ <a class="header-anchor" href="#vite的hrm热更新和webpack-hmr的有什么不同" aria-label="Permalink to &quot;Vite的HRM热更新和webpack HMR的有什么不同？&quot;">​</a></h2><ol><li><code>按需编译：</code>Webpack 在启动时需要对整个应用应用进行一次完整的编译，而Vite只对请求的模块进行编译，而不需要像传统的打包工具那样等待整个项目编译完成</li><li><code>基于 ESM 的 HMR</code>：Vite 的更新则是基于浏览器原生的 ESM ，浏览器可以直接请求和缓存更新的文件，无需通过 webpack 的运行时进行处理，从而提高更新的效率</li><li>响应速度：热更新实质上是一次新的 HTTP 请求，而 Vite 在发送这个请求的时候使用了 HTTP/2，避免了 HTTP/1.1 的队头阻塞（Head-of-line Blocking）问题，加快了更新。</li></ol><h2 id="vue-loader的实现原理" tabindex="-1">Vue-loader的实现原理 <a class="header-anchor" href="#vue-loader的实现原理" aria-label="Permalink to &quot;Vue-loader的实现原理&quot;">​</a></h2><p>Vue-loader 是 webpack 的一个 loader 转换器，是用来解析和转换 .vue 文件的工具。</p><ol><li>**解析：**vue-loader 通过 <code>vue-template-compiler</code> 解析<code>.vue</code>文件，并返回一个描述该 .vue 文件结构的JS对象。这个对象中包含 template、script 和 styles，以及它们的内容，和一些其他的元信息。</li></ol><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&lt;div class=&quot;demo&quot;&gt;{{ msg }}&lt;/div&gt;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// template内容</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    attrs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lang</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;html&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// template的属性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;export default { data() { return { msg: &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Hello world</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39; }; } }&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// script内容</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    attrs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lang</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// script的属性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  styles</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    content: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.demo { color: red; }&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// style内容</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    attrs: { lang: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;css&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, scoped: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// style的属性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }], </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  customBlocks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [], </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 其他自定义块</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  errors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 指示解析过程中出错的错误数组</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="2"><li><strong>转换为module</strong></li></ol><p>解析出的每一个部分（template、script 和 styles）都会转化为一个 JavaScript 的模块。方便 webpack 能够理解和处理这些代码。</p><ol start="3"><li><strong>对应 Loader 处理：</strong></li></ol><ul><li>对于 script，使用 babel-loader 或者 ts-loader 对其进行处理；</li><li>对于 template，首先通过 <code>vue-template-compiler </code>将模板转换为 JavaScript 渲染函数，然后交给 babel-loader 或者其它 JavaScript loader 进行处理；</li><li>如果 styles 是 SCSS 或者 Less，会先通过对应的 loader 进行预编译，然后交给 css-loader。</li></ul><ol start="4"><li><strong>热重载：</strong></li></ol><p>vue-loader 会注入一些热重载的代码，让修改后的组件可以在不刷新页面的情况下替换掉之前的组件。</p><ol start="5"><li><strong>Scope CSS：</strong></li></ol><p>vue-loader 提供了 CSS 作用域的功能，就是通过为模板生成的元素添加特殊的属性，让这部分 CSS 仅作用于当前的组件。</p><blockquote><p>vue-loader 的实现原理是利用 webpack loader 对 .vue 文件的各个部分进行逐个处理，然后使用 webpack 的强大功能将这些不同类型的资源整合到一起，制作成为一个前端项目需要的外部资源。</p></blockquote><hr><ul><li><a href="https://webpack.wuhaolin.cn/5%E5%8E%9F%E7%90%86/5-1%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%A6%82%E6%8B%AC.html" target="_blank" rel="noreferrer">5-1 工作原理概括 · 深入浅出 Webpack</a></li><li><a href="https://juejin.cn/post/6844904094281236487?searchId=2024041121185627BE6E53379F7F3FC780#heading-4" target="_blank" rel="noreferrer">「吐血整理」再来一打Webpack面试题 - 掘金</a></li><li><a href="https://juejin.cn/post/7023242274876162084?searchId=2024041121181549203A7A7826B7431D41#heading-48" target="_blank" rel="noreferrer">🔥【万字】透过分析 webpack 面试题，构建 webpack5.x 知识体系 - 掘金</a></li><li><a href="https://webpack.js.org/contribute/writing-a-plugin/" target="_blank" rel="noreferrer">Writing a Plugin | webpack</a></li></ul>`,94),t=[p];function e(h,k,r,E,d,o){return a(),i("div",null,t)}const y=s(l,[["render",e]]);export{g as __pageData,y as default};
